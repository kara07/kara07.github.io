---
layout:          post
title:           "TFHE"
subtitle:        "ドーナツ食べたくなくなるわ(*´_ゝ｀)"
date:            2022-09-22 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

重头戏都在这一篇。

# Modulus Switching

换模数。TFHE 里面一般用在 LWE 密文，也可以拓展到 GLWE 密文。

比如正整数 $\omega$，将 LWE 密文的所有部件的模数从 $q$ 更换到 $\omega$：

$$\tilde{a}_i = \left\lfloor \frac{\omega \cdot a_i}{q} \right\rceil \in \mathbb{Z}_\omega.$$

所以结果是一个新密文：

$$\tilde{c} = (\tilde{a}_0, \ldots, \tilde{a}_{n-1}, \tilde{a}_n = \tilde{b}) \in LWE_{\vec{s}, \sigma}(\tilde{\Delta} m) \subseteq \mathbb{Z}_\omega^{n+1}.$$

一般换到更小的 $\omega$，且都是 2 的幂，$p < \omega < q$，所以 $\Delta$ 相应变为 $\tilde{\Delta} = \frac{\omega \cdot \Delta}{q} = \omega/p$。如果不是 2 的幂需要 rounding。

操作形象描述为保留原密文的 $\log_2(\omega)$ MSB，也就是消息编码的地方，这么做噪音会变大很多，i.e.，离消息编码的位置更近(~~$\Delta$ 变小了~~)。小心使用。

![](/img/TFHE/mdlsSwch.png)

# Sample Extraction

将 GLWE 多项式密文的一个系数(对应明文多项式的一个系数)拎出来作为一个 LWE 密文。

![](/img/TFHE/smplExtc.png)

不增加噪音，只是简单的复制 GLWE 密文的一些系数输出 LWE 密文。

对于 GLWE 密文加密了 $M = \sum\_{j=0}^{N-1} m\_j X^j \in \mathcal{R}\_p$，密钥是 $\vec{S} = (S\_0 = \sum_{j=0}^{N-1} s\_{0,j} X^j, \ldots, S\_{k-1} = \sum_{j=0}^{N-1} s\_{k-1,j} X^j) \in \mathcal{R}^k$，是一个 $k+1$ 元组：

$$C = \left(A_0 = \sum_{j=0}^{N-1} a_{0,j} X^j, \ldots, A_{k-1} = \sum_{j=0}^{N-1} a_{k-1,j} X^j, B = \sum_{j=0}^{N-1} b_j X^j \right) \in GLWE_{\vec{S}, \sigma}(\Delta M) \subseteq \mathcal{R}_q^{k+1}$$

如果想要提取 消息 $M$ 的第 $h$ 个系数，$0 \leq h < N$，LWE 密文 $n = k N$，且密钥为提取的密钥 $\vec{s}$，为 GLWE 密钥的系数复制。

$$\vec{s} = (s_{0,0}, \ldots, s_{0,N-1}, \ldots, s_{k-1,0}, \ldots, s_{k-1,N-1}) \in \mathbb{Z}^{kN}$$

之后通过简单复制一些 GLWE 密文的系数构建 LWE 密文 $c = (a\_0, \ldots, a\_{n-1}, b) \in \mathbb{Z}^{n+1}\_q$：

$$\begin{cases}
a_{N\cdot i + j} \leftarrow a_{i,h-j} &\text{ for } 0 \leq i < k, 0 \leq j \leq h \\
a_{N\cdot i + j} \leftarrow - a_{i,h-j+N} &\text{ for } 0 \leq i < k, h+1 \leq j < N \\
b \leftarrow b_h & \\
\end{cases}$$

Blind Rotation

把「禁則事項」多项式第「禁則事項」项多项式系数转到常数项。

因为位置 $0 \leq \pi < N$ 是一个整数，Cmux 选择端输入是一个 bit，首先将其二进制表示：

$$\pi = \pi_0 + \pi_1 \cdot 2 + \pi_2 \cdot 2^2 + \ldots + \pi_\delta \cdot 2^\delta$$

其中 $\delta = \log\_2(N)$，我们想算的是：

$$\begin{aligned}
M \cdot X^{-\pi} 
&= M \cdot X^{-\pi_0 -\pi_1 \cdot 2 -\pi_2 \cdot 2^2 + \ldots -\pi_\delta \cdot 2^\delta} \\
&= M \cdot X^{-\pi_0} \cdot X^{-\pi_1 \cdot 2} \cdot X^{-\pi_2 \cdot 2^2} \cdot \ldots \cdot X^{-\pi_\delta \cdot 2^\delta}. \\
\end{aligned}$$

拎一个 $X^{-\pi\_j \cdot 2^j}$ 出来，因为 $\pi\_j$ 是 bit，算这玩意只有两种情况：

$$M \cdot X^{-\pi_j \cdot 2^j} =
\begin{cases}
M &\text{ if } \pi_j = 0 \\
M \cdot X^{-2^j} &\text{ if } \pi_j = 1 \\
\end{cases}$$

用一个 CMux 实现：

![](/img/TFHE/blndRttn.png)

递归的计算所有多项式项，所以表现为 $\delta$ 个 CMux 串联。

![](/img/TFHE/blndRttn2.png)

# Bootstrapping