---
layout:     post
title:      "I'M BACK & AEAD"
subtitle:   "RETURN"
date:       2022-05-12 00:00:00
author:     "kara"
header-img: "img/tktopink.jpg"
tags:
    - crypto
    - AEAD
---

# 回归

> ~~奇奇怪怪的标题~~

看了看上一篇文章更新时间已经是2019年六月，现在已经是2022年五月了。好家伙，咱三年没更...

说起原因的话本来最开始创建这个站点是为了记录一些知识，方便以后用到的时候回来查，但后来慢慢的觉得光是记录的话onenote之类的反而更方便，于是就懒得更新了。但其实折腾这个站点本身也是十分有趣的，包括右下角这只抓包抓出来的kokoro。包括咱现在也有很多需要记录的需求，于是又回来了。

这篇文章不知道写什么好，随便记录一下AEAD的浅显学习吧。

# AEAD:新的传输标准

在TLS1.3标准[(RFC8446,2018)](https://datatracker.ietf.org/doc/html/rfc8446)中，移除了所有独立的对称加密模式和消息认证模式。比如，在TLS1.3标准中，已经不可以使用类似RC4的流式密码，或是工作在各种传统模式下的DES,AES分组密码，取而代之的是一种被称为AEAD[(RFC5116, 2008)](https://datatracker.ietf.org/doc/html/rfc5116)的新的对称加密结构。TLS1.3作为国际互联网工程任务组(IETF)所制定的标准化传输层安全协议(TLS)的最新版本，是该任务组旗下最重要的安全协议之一，用于保护web等应用层应用，提供加密并确保每个HTTPS网站和API的真实性。TLS1.3中所简化的密码套件协议中对密文加密模式做出了如此重大的修订或许也标志着在互联网端对端加密传输中将传统对称密码与消息认证码单独使用已成为过去式，AEAD将作为更安全的对称加密模式为未来的互联网提供支持。

## 什么是AEAD？

AEAD即带有关联数据的认证加密（Authenticated Encryption with Associated Data，AEAD）。用于 TLS 连接的常见 AEAD 是 ChaCha20-Poly1305和AES-GCM。在TLS1.3问世之前，一些用于隐蔽和混淆网络流量的基础网络工具中就已经引入了AEAD加密模式，例如未被引入TLS1.3标准的目前最受 libsodium 项目推荐的 AEAD算法XChaCha20-IETF-Poly1305。

AEAD算法 支持两种操作：“密封”和“打开”，即传统意义上的加密与解密。“密封”操作接收以下内容作为输入：

1.  要被加密的消息，即明文。
2.  一个密钥
3.  一个独特的初始向量，也就是$IV$。它在使用相同密钥的“密封”操作调用之间必须是唯一的，否则密码的保密性将被完全破坏。
4.  可选的其他一些非秘密的附加数据。这些数据不会被加密，但会被认证。这是 AEAD 中的 AD。

“密封”操作使用密钥和$IV$，使用底层密码将明文加密成等长的密文。对于 ChaCha20-Poly1305，底层密码是 ChaCha20，而对于 AES-GCM，底层密码是 Counter 模式下的 AES (AES-CTR)。

明文被加密后，“密封”操作使用密钥（以及可选的$IV$）生成二级密钥。二级密钥用于生成 AD的一段引入密钥的哈希值、密文和各自的对应长度。 ChaCha20-Poly1305 中使用的散列算法是 Poly1305，而 AES-GCM 中使用的散列是 GHASH。

最后一步是获取哈希值并对明文进行加密，生成最终的 MAC（消息认证码）并将其附加到密文中。

“打开”操作与“密封”相反。它采用相同的密钥和 IV 并生成所输入的密文和 AD 的 MAC，类似于“密封”所做的操作。然后读取密文后附加的 MAC，并比较两者。 MAC 值的任何差异都意味着密文或 AD 被篡改，这样的密文应该被视为不安全而被丢弃。反之，如果两者匹配，则操作解密密文，返回原始明文。

## AEAD实例分析

下文以ChaCha20-Poly1305算法实例详细解释AEAD算法流程：

![avatar](/img/AEAD/c.jpg "ChaCha20-Poly1305加密流程")

如图所示，ChaCha20-Poly1305加密流程的输入和输出为以下数据：