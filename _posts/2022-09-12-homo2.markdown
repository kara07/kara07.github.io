---
layout:          post
title:           "Fully H0M0morphic Encryption II"
subtitle:        "十分难顶，甚至有九分。"
date:            2022-09-12 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

稿子记一记，免得講论文时脑子抽筋。

组织了五个章节。首先简单讲讲全同态加密的一些常识，比如什么是 FHE。然后深入讲一下 TFHE。主要介绍 TFHE 所用到的密文。然后讲解一下用这几种密文构成的单元(building blocks)和使用这些构成单元的混合操作。接着是如何进行自举(bootstrapping)。如果大家感兴趣再讲讲技术细节。

# FHE

## 什么是 FHE

FHE 所实现的功能概括来讲就是将密文的操作权和所有权分开。

比如这张图里的明文 $x$，用一个带锁的蓝色盒子表示对其加密。这个带锁的蓝色盒子表示里面的明文对应的密文。FHE 允许对密文执行运算，最简单的就是加运算。比如有 $x$ 的密文和 $y$ 的密文，我们对密文进行加运算，结果将是 $x+y$ 的密文。乘法也是一样，我们对 $x$ 的密文和 $y$ 的密文进行乘操作将会得到 $x\times y$ 的密文。需要注意的一点是对密文空间的操作标成了黄色，而对明文空间的操作标成了红色。原因是对密文空间的操作将会比对明文空间的加和乘稍微复杂一点点。后面将会看到在 TFHE 中是怎样实现的。

FHE 意味着全同态，我们希望能没有任何限制对密文执行任意由加法和乘法所组成的函数。同时我们希望能对任意明文进行加密，包括 bit,integer,real messages。我们也希望能够实现secret key,public key~~对称非对称~~两种加密模式。这次我们只关注对称模式，因为不同于传统的密码学体系，在全同态里对称和非对称加密体系是等价的。一个非对称的加密体系可以由对称体系很容易得到，[先了解可以看这个](https://people.csail.mit.edu/vinodv/6892-Fall2013/rothblum.pdf)(~~通过密钥派生~~)。

FHE 在云服务场景下很有价值，能充分保护隐私。比如有一个云服务提供商，它提供了很多有用的计算服务，但现实生活中有敏感数据不想让云服务商以及监听信道的第三者得到，就需要借助密码学将其加密上传给云。但密文无法执行很多操作，如果需要这些操作还需要对其解密。但如果使用全同态加密，云服务提供商在不解密的情况下也可以对加密的数据进行计算服务，数据在整个生命周期内都是加密的状态，因此只有数据拥有者才能够获得数据。对于服务器来说，不存在数据泄漏，因为就算云服务器被黑客攻破，数据也同样是加密的。对服务器的部署也将没有限制，可以部署在世界各地适应每个地区的隐私政策。

假设你是个计算机视觉的苦逼学生(~~假设不需要这个假设~~)，买不起非常高级的设备，必须要借助云炼丹服务来完成自己的科研，这时候你肯定不希望自己的数据集，模型被云服务提供商或是其他第三方剽窃，这时候就可以借助全同态，将加密的数据集和代码上传至云计算服务器，在密文上计算返回给你加密的模型，然后再用你自己的密钥进行解密。云服务器在不知道你上传的是啥的情况下帮你炼了丹。

另一方面 FHE 可能会在未来改变互联网的工作模式，$HTTPS\to HTTPZ$，默认使用全同态加密协议与服务器建立连接，服务器将不会得知你发送的任何敏感数据比如电话号码，位置，ip，密码，且仍能够为你提供服务(~~现阶段只是一种设想~~)。

但是，~~古尔丹~~，代价是什么呢？全同态加密过程中的代价主要是一些叫做噪音的随机数。之前一张图里展示了对密文进行加操作和乘操作的过程，实际上当我们对明文进行一次加密之后就已经加入了一定的噪音。噪音实际上就是确保密码学功能安全的随机数，我们需要密码学功能是概率性的，所以至少现在没办法不用他们。这里用密文右上方的温度计表示噪音程度。最开始噪音程度很低，但当我们进行同态的加或者乘操作之后噪音会变大。特别是进行乘操作之后噪音会比加操作更大。噪音控制非常重要，因为如果噪音超过临界值，也就是温度计上的红线，将有概率无法正确解密。这是让全同态在 2009 年之前无法实现的原因之一。

## bootstrapping[[Gen09](http://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf)]

2009年，Gentry 用了一个很巧妙的方法 ，我把它翻译成自举(bootstrapping)。自举功能就是在噪音即将突破临界值时减小噪音。后面会详细讲讲 TFHE 的自举。

自举的思想是：对于一个密文 $x$，它的噪音即将突破临界值，所以我们将无法对其进行任何同态操作，只能停下来，或者想办法降低它的噪音。最简单的降低噪音的方式就是对它解密，把明文从盒子里拿出来，那么噪音也将不复存在。但解密需要密钥，密钥又不能交给云或者其他第三方来刷新噪音，不然我们加密也就没有意义。

Gentry 的方法是直接保留噪音很大的密文，就是这个蓝盒子，然后再把它放在一个绿盒子里。这个绿盒子是再一次的全同态加密。把蓝盒子放在绿盒子里面也不会改变蓝盒子的噪音。但由于这是一次全同态加密，绿盒子也会如温度计所示的带有一定的噪音，现在我们要做的是打开绿盒子里面的蓝盒子，也就是对蓝盒子解密。打开蓝盒子需要蓝色的钥匙。所以我们得给他蓝色的密钥，但是得把它装在绿盒子里。我们将这个密文叫做自举密钥(bootstrapping key)，这是一个公开密钥，并且不会暴露我们手上的密钥信息。现在我们有一个装在绿盒子里的蓝盒子和一个装在绿盒子里的蓝钥匙，我们可以同态解密打开蓝盒子，结果将会得到一个绿盒子对明文的加密。绿色的温度计比之前会上升一点，但距离临界值还有一定的空间，这允许我们进行进一步的全同态操作。在实践中我们可以在进行同态操作之后尽快的自举，这样就会有一定的空间可以操作，然后又回到自举开始之前。所以通过链式的不断循环自举我们可以构造任何电路，不再有操作次数的限制。

## 两条支线

尽管自举是一个非常有用的技术，但它是 FHE 开销最大的操作。所以又有不同的声音说在构造全同态加密的时候需要一直自举吗？答案是具体问题具体分析。如果你想同态(~~我翻成~~)计算(evaluate)的电路很小，并且你对他的构造很清楚，也就是说知道要对它进行多少次同态运算，那我们对他采取(~~我翻成~~)精准的方法(leveled approach)，如果电路很大，并且你作为生成密钥的人不知道它的构造，那么我们就采用自举方法(bootstrapped approch)。

精准方法会尽可能避免自举，在进行同态计算之前必须知道要进行多少次操作，然后固定参数来适应这些操作，让噪音控制在可接受的范围内。当然电路越大，参数设置的越大，运算将会变得更慢，所以有越多的操作要执行，开销也会越大。

但如果需要更加灵活或者是电路未知，这时候可以用自举方法，这样对操作次数就没有限制，但需要不断对电路进行自举。

## 时间线

那我们怎么使用全同态，是用一种方法还是两种都用？我将会用一条高度概括的时间线解释，只会列出一些代表性的文章。第一次提出实在 1978 年，然而这个问题非常难，经过 30 年也没有找到一个解决方法，这段时间诞生的方案被称为部分同态，可能是只有加或者乘，也可能是能同时进行加和乘运算，但存在限制比如能无限制加运算但只能进行一次乘运算。直到 2009 年 Gentry 提出了自举和可以用理想格之后学者们提出了很多很棒的成果。2010 年提出了 DGHV，是一个基于格上的 Approximate-GCD 问题在整数上进行操作的方案。虽然现在基本不被使用了，但他是一个很直观的方案。很适合解释什么是全同态。然后在 2011 年，第一个基于 LWE 困难问题的 FHE 方案被提出，叫做 BGV。LWE 是另一个格上的平均情况计算困难问题，有很多优越性。之前也讲过比如抗量子计算攻击，存在最坏情况到平均情况的归约，具有密码学完备性等等。之后在 2012 年，另外一个也是基于格问题的 NTRU 的分支被提出，虽然 NTRU 后面被一定程度破解了，现在会面临一些重大的安全性问题，但也是很好的方案。2013 年有了另一个基于 LWE 的方案叫做 GSW 方案。现在所更为充分研究的就是基于 LWE 问题的分支，也就是 BGV 和 GSW 分支。后面出现了很多的变体。所以延续到至今的有主要有两个分支，一个是 BGV 分支，更加偏向于精确方法，避免使用开销大的自举，以及 GSW 分支使用更快的自举，允许我们尽情使用自举。BGV 分支后来有了 CKKS，是一个使用至今的著名方案，同时在 GSW 分支有了 TFHE，也就是这次要讲的。TFHE 最开始是对前面的 FHEW 的提升，之后发展出了很多功能。如果看过这两条支线的构造就会发现实际上这两条支线之间的差别比想象的要小，并且最近的趋势在不断融合。比如 [BGGJ19] 提出了一种通用框架使得 TFHE 和 HEAAN[CKKS17]可以同时工作，或者说可以很简单的变换到另一种方案。这篇文章也是综合了两条支线完善后的 TFHE，可以同时用上面说的两种方法。22 年最新的研究也是在 TFHE 上特别是自举上进行改进。

# TFHE

现在让我们抛开一些技术细节简单的看一看 TFHE 方案。如果对代数和格计算问题不是那么熟悉也没关系，我会讲的尽可能简单。

## TFHE 密文

### LWE

首先从 TFHE 的密文开始。TFHE 里一共有三种密文，第一种叫 LWE。LWE 就是格上的一个困难问题，我们用这个问题来来加密明文。LWE 密文用来加密一个消息，可以是一个 bit，一个模整数，一个特定区间内的实数。密钥是一个短向量，每个元素都是一个 bit，可以看成是随机 bit 向量。bit 类型不是强制的，也可以用其他类型的密钥，比如 LWE 问题常用的 ternary keys，i.e.，$\qty{-1,0,1}$,gaussian keys。这里我将重点关注比特密钥。

密文由 $n+1$ 个元素组成，前 $n$ 个元素是向量 $a$，最后一个元素是 $b$。$a\_i$ 均匀随机的在 $\mathbb{Z}\_q$，i.e.，模 $q$ 整数中采样。最后一个元素 $b$ 由所有 $a$ 元素和密钥 $s$ 的乘积组成，然后再加上特定的噪音 $e$，和密文和标量 $\Delta$ 的乘积。这里的噪音 $e$ 服从高斯分布。所以均匀随机的 $a$，乘上密钥的随机元素，然后加上噪音，和消息，然后就得到了 $b$。

解密时我们知道密钥，直接计算 $b-\mathbf{a}\mathbf{s}$ 就会得到 $\Delta m+e$，然后我们进行取整(rounding)，把 e 舍入掉，就得到了 $m$。

取整是一个非常简单的操作，通过这张图就能很好理解。这张图只是一个可视化的很简单的例子，并不是真正使用时的参数。当我们对 $q$ 取模时，就像用了一个转盘(Torus)一样。就是这个圈圈，0 在底部，逆时针依次增大，1,2,3 一直到61,62,63，$q=64$，所以当我们数到 64 就又回到了 0。这就是模 $q$ 的思想。如果我们设定 $q$ 等于 64，那么我们可以使用最多 6 bit 的密文。然后选一个 p，p 是我们想要加密的明文的数量，在这个简单例子里是 4 个元素。这意味着我们有两个 bit 的明文信息。$\Delta$ 则是 q 和 p 的比。p 是我们可以加密的明文的数量，也就是只有这四个元素里面一个消息能够加密到密文里面。也就是总共有四种选择。所以有两个 bit 表示他们。我们将把它加密到密文的 MSB，i.e.，最高位 bit。$\Delta$ 在这里表示了这个转盘上的一个消息和第二个之间的距离。所以每个消息之间会分散开 $\Delta$ 距离。之前说过我们要能够解密，噪音的大小就必须被限制。它被限制为 $\Delta/2$。在加密过程中我们把噪音放在密文的 LSB，最低位 bit。在这个转盘里红色的线表示对特定密文添加的噪音的范围，不能超过这条红色的线。

我们给出一个非常简单的例子。比如我们想对 3 加密，3 将被编码为 $\Delta m$ 在这个例子里等于 48，在转盘的这个地方。在密文的最高位编码了二进制的 3，然后我们加上一些大小是 5 的噪音，它被编码到密文的最低位，最终密文得到了对 53 的加密。53 在转盘的这里。解密时先算 $b-\mathbf{a}\mathbf{s}$ 然后得到了 $\Delta m+e$，知道 $\Delta m+e$ 恢复出 $m$ 非常简单，只需要对 $\Delta m+e$ 取整到最近的可能消息，也就是 $\Delta m$ 知道了 $\Delta m$ 恢复出 $m$ 就很直接了。这只是一个迷你例子，真正用到的 $q$ 不会是 64，而是 $2^32,2^64$ 之类的大数。这是 TFHE 里常用的参数。

因为在讨论全同态加密，所以我们希望对密文进行一些全同态的操作。用 LWE 可以实现加法，直接把两个 a 部分和 b 部分加起来结果就是第一个明文和第二个明文的密文。在这之上拓展也可以实现整数的数乘，只需要直接对 a 和 b 分别数乘就会得到对应明文的数乘。但很遗憾我们不能对两个 LWE 密文进行相乘，乘法运算会在之后的部分用其他密文实现。

LWE 是第一种密文类型，第二种是 RingLWE。RLWE 不只可以加密一条信息，他可以加密一个含有许多系数的多项式，每一个系数都是一个 LWE 里的消息，可以是一个比特，一个整数或者是实数。所以我们加密的是一个多项式，有 N 个系数。密钥也不再是一个向量而是一个多项式，系数这里是一个 bit，同样也不是强制的，也可以是 ternary，gaussian。在这里我们还是只关注二进制的。密文用一种跟 LWE 非常相似的方式进行加密。所以你有 A 部分和 B 部分。A 和 B 这次代表多项式。A 多项式也是均匀随机的，所以这里是随机的模 q 的整系数多项式，B 部分和之前构建的方式一样，只是现在我们在对多项式进行计算，所以我们现在用 A 乘 S 加上一个高斯分布的噪音，然后加上 delta 乘上消息。delta 现在也是一个多项式。

解密的方式也是一样，如果知道密钥，就直接算 b-as，然后结果就是 delta m+e，最后对他取整得到消息 m。

所以跟之前一样，知道 delta m+e 能够简单的恢复出 m。只不过我们现在不是只有一个转盘，而是对于多项式的每一个系数都有一个转盘。所以只要把之前的操作重复 n 次就可以了。

同样的我们可以实现加法和数乘，乘上一个整数多项式的常量。计算过程和之前相同，加法就直接将密文的 A 和 B 相加，数乘则是将 A 和 B 都乘上一个整数多项式。然后会得到多项式 gamma 乘 m 的密文。

最后一种密文，同时也是最重要的，是 RingGSW。跟 RingLWE 类似，它将对一个有 N 个系数的多项式进行加密，密钥和 RingLWE 的密钥一样，是一个系数是 0 和 1 的多项式。但是现在密文将会复杂一点点，这里会用一个三维的矩阵表示它，这个矩阵在不同深度有很多层，总共有 l 层，在前面的每一层都由四个多项式组成，第一行有两个，第二行有两个，每一个多项式都是一个 RLWE 的密文，也就是之前我们见过的第二种密文里的。第一行我们对消息 mu 乘上密钥乘上固定的 beta 的 j 次方分之 q，j 从 1 取到 l。在第二行我们对消息 mu 乘上 betaj 分之 q，这里没有密钥 s。上下都有 mu 乘 betaj 分之 q，只不过上面多乘一个密钥 S。

这个看上去比之前的都要复杂一点，但这个结构允许我们对他进行更多的操作。所以我们可以做加运算，可以做乘上一个常量多项式，方法也跟之前一样，分别对 A 和 B 部分相加，或者对其乘上一个常量多项式。但现在我们可以同样实现乘法运算，这是前面两种密文所做不到的。

乘运算并没有那么直观，并不是难。现在有两个密文一个加密了 mu，一个加密了 mu' 然后你想计算这两个密文。这样的乘法运算由两个步骤实现。第一步我翻译成解构(decomposition)。首先给第一个密文拎出来，首先只看这个密文的一层，也就是一个 2x2 的矩阵。其他层也是一样的执行。要做的是解构每一个多项式为很多小多项式。这里也就是 l 个小多项式。这里的 Aj 将会被解构为这 l 个小多项式，Bj 则是这 l 个小多项式，依次类推。解构是一个很容易实现的操作，并且运算速度很快。然后是第二步，第二步就是矩阵点乘。将第一步解构得到的小多项式乘上第二个密文。这个乘法就是矩阵点乘，将对应的多项式的积求和。然后得到一个输出的多项式，也就是输出的密文。所以如果对密文的每一层都重复相同的操作，就能够得到对应的输出的所有层的结果。输出的密文代表了mu和mu'的乘积。虽然看上去是一个很复杂的操作，但实际上很好去实现。

接下来是这个部分的最后一张幻灯片，是一个总结，总结了我们到目前干了些什么。我们有三种类型的密文，LWE,RLWE 和 RGSW。LWE 有一个向量和一个元素 b 组成，能进行加和数乘运算。RLWE 由两个多项式组成，同样能进行加和数乘运算。RGSW 稍微复杂一点，由一个三维的矩阵组成，但同时可以进行加，数乘以及乘法运算。

# 组成单元和混合操作

现在我们要把这些密文组合在一起。第一个操作是(~~我翻译成~~)外积(external product)。虽然它叫外积，但是他的运算是内积。它跟 RingGSW 密文的乘法非常类似，但比他更简单。叫做外积是因为它是两个不同元素之间的乘法，RingLWE 和 RingGSW。这两种不同的密文进行乘法的结果是一个 RLWE 密文。并且其对应的明文是 mu 和 M 的乘积。在操作上跟 RingGSW 非常类似，首先对 RLWE 密文进行解构，同样的 A 元素被解构成一系列小多项式，B元素也同样。然后第二步是解构出来的矩阵跟矩阵的点乘。外积运算比乘法更快。

外积运算非常重要，通过他可以定义另一种组成单元叫做 CMux，意思是 Controlled MUX，可控制的数据选择器？MUX 门如图所示，输入三个元素，b,d0,d1。取决于输入 b 是 0 还是 1，它选择输出 d0 或者是 d1。所以如果 b 等于 1，它就输出 d1，b 等于 0，它就输出 d0。所以这个门电路的功能可以用这个逻辑表达式表示。如果 b 等于 0，前面一项就没了，只剩下 d0，如果 b 等于 1，就只剩下 d1。这个门电路的实际功能等同于 if 控制语句，我们可以这样同态的实现他，把乘法替换成外积...
这个元件非常有用，在后面的构造尤其是自举里面会用到非常多。

第一个组成单元是旋转(Rotation)。我将会由简到难的介绍这个功能。我们先从已知的一个多项式开始。如果我想旋转这个多项式到p位置。M 是这个多项式，M0+M1+++，最高次小于 N，因为我们在 mod XN+1 上进行操作。我们想要获得的是系数 Mp。所以我们得旋转这个多项式使 Mp 旋转到第一个。操作非常简单，只需要对这个多项式乘上 X-P 次方，然后 Mp 就成了多项式的第一个系数，也就是 X 的 0 次方，常数项的系数。其他后面系数跟在他后面，它前面的系数将会在多项式最后系数变为负数，因为我们在 mod XN+1 上进行操作。所以这个操作很简单，只需要乘上 X-p 就行了。

现在增大一点难度对 M 的密文的 p 位置进行旋转。所以 M 是加密后的，p 已知。M将会用 RingLWE 加密，也就是橙 色的密文。密文和常多项式的乘法之前讲过很简单，只需要对 A 部分和 B 部分对应相乘就行了。结果将会是 M 乘 X-P 的 RLWE 密文。也就是旋转过后的 M 的密文。所以同样也很简单，这个操作没有增加任何噪音。

但再难一点，不只是 M 加密了，位置 p 也加密了。也就是我们想要去获得的系数的位置也被加密了。我们先将 p 表示为二进制形式，分别是 p0,p1,pk，假设这些二进制数以 RGSW 密文的形式提供。也就是说这 p 个元素未知，他们都是密文，2^j 是一个常量，当然知道。现在我们想要计算的是 M 乘上 X-P 来进行旋转。M 乘上 X-P 可以写成这样的二进制形式，他就等于...让我们关注其中的一项...我们直接计算...再重申一遍 M 是加密的 p 也是加密的，所以让看一下我们想得到怎样的输出。如果 p 等于 0 指数就是 0，这一项就变成了 1，输出将会变成 M。所以如果 pj 是 0，我们将得到输出的 M；如果 pj 等于 1，指数将会变成 2j，所以我们将得到输出的结果是 X 的 2j 次方。所以可能大家已经懂了，这是一个 if 条件判断，我们实现 if 的方式就是用上面提到的CMux。在这里 CMux 0 端输入 M 的密文，在对应 1 端输入 M 的密文乘上明文的...然后通过选择器 pj 的密文进行判断。输出结果是...也就是我们想得到的。

如果这一步清楚了，对整个 p 进行操作只需要构造一个 CMux 门组成的链。所以我们由 0 开始，输入密文...你将会得到一个密文 M0，他的值是...然后吧 M0 作为输入，传递到下一个 CMux 门，然后你将会得到 M1，然后一直下去最终得到 M 乘 X-P。

所以我们可以通过这种方式实现盲转，也就是对未知的多项式的未知位置进行旋转。

这个可能是最难的构造单元，后面的会简单很多。下一个是采样提取器(sample extraction)，他输入一个 RLWE 密文，加密的是多项式 Mx，他的构造方式前面已经看过了，然后你想要把多项式 M 的系数提取出来。这意味着你不知道 M，但你想得到他的一个系数，作为 LWE 密文。这里以 M0 做例子。这个很简单，只需要以特定顺序重新排列 M，然后复制输出的 LWE 密钥为对应 RLWE 密钥的系数向量。这个操作不会增大噪音，只需要重新排列 M 的系数就可以了，当然不只是 M0 可以被提取出来，任何一个系数都可以被提取出来，只需要以合适的方式重新排列输出的系数。

最后一个也很重要，是密钥更换。假设你有一个输入的 m 的密文，其对应的密钥是 s，你想要输出一个同样是 m 的密文，其密钥是 s'，这个操作需要一个密钥叫做密钥更换密钥，是一个公钥，跟后面会提到的自举密钥非常相似。不只是可以交换密钥，也可以更换参数，如果需要更换参数，也可以通过这个操作。密钥更换不只可以在 LWE 和 RLWE 密文实现，也可以从 LWE 到 RLWE。用处有点像你想的采样提取。采样提取使一个 RLWE 的参数到 LWE，密钥更换可以输入一个 LWE 密文，然后将其明文放到 RLWE 多项式的一个参数里。再广一点可以把很多 LWE 明文放到一个 RLWE 里面。有点类似打包。

密钥更换同时可以同态计算一些常规的函数，可以是公开的或者是非公开的，我们把它叫做功能型密钥更换(functionality key switching)。但很遗憾这个组成元件会增加噪音。虽然输出会有更高的噪音，但很多时候它的功能非常重要。

这是最后一个组成单元，最后用一张幻灯片总结。我们定义了外积和 CMux，使 RLWE 和 RGSW 得以交互，输出一个 RLWE 密文。我们可以进行旋转操作，所以我们可以旋转 RLWE 密文。我们可以进行采样提取，可以提取 RLWE 密文的一个参数到 LWE；如果需要，我们可以用密钥更换回到 RLWE。

# bootstrapping

接下来是最具有技术性的最后一个部分。自举的作用是降低噪音。TFHE 里我们可以对 LWE 密文进行自举。自举需要去执行解密电路，也就是打开蓝盒子。我们将同态的打开蓝色盒子来降低噪音，所以明文将会一直保持加密状态。解密的步骤分为两步，第一步就是前面提到的计算 b-as 然后得到 delta m+e。第二步对它取整获得明文 m。

自举想要得到一个噪音更小的同样是 LWE 加密的密文。让我们首先先从第二步开始，倒过来看。所以我想对 delta m+e 取整，这是我的目标。同样从易到难，假设明文 m，之前说过可以有 p 中不同的取值，这些值都被加密进了一个多项式的系数里，这里以一个向量表示。如果我想要提取出消息 m，假设被加密在中间，我要做的就是对这个多项式进行旋转，也就是乘上 X-m，m 就会被放到第一个系数，我们就得到了 m。

现在来看我们的目标，我们不知道 m，m 是我们要得到的，我们现在要得到 delta m+e。现在有 0 到 q-1 q 个可能的值，被加密到这个多项式里，然后我们想提取出 delta m+e，做法跟上面一样，只需要乘上...就能把 delta m+e 带到第一个位置。我们通过旋转操作将想要的系数放到第一个位置。

现在我们得到了 delta m+e，想要得到 m。我们需要对旋转操作的向量做一些变化。我们不再只给出 0 到 p-1，而是对它添加一些冗余，我们需要重复里面的每个明文元素。也就是不再是 0 到 q-1，而是重复 delta 个 0，delta个 1 一直到 delta 个 p-1，因为我们的消息是从 0 到 p-1。这里总共有 p 个元素，而他们的排列方式正好是一个 Torus，这个向量里面的 q 个值正好是 Torus 里面每个离散的刻度。delta 正好是红线区域的长度，所以每个重复的元素都代表着被红线划分的一个区域。这里我将 0 一分为二，为了能更好的体现这个转盘的思想。如果我们从 0 开始，逆时针不断增加，最后又回到另一半的 0。如果这个消息没有任何噪音，消息 0 就会正好落在起点，如果有一定不超过限度的噪音，消息加噪音就会落在 0 的红框范围内，但消息的值还将会是 0。

所以我们对这个向量，这个多项式进行旋转，如果它不包含噪音，m 将会作为第一个系数正好落在起点，如果有噪音，它将会偏移一些，但始终还是在全都是 m 值的红框里。所以借助这个向量，我们完成了对 delta m+e 的取整。我们输入了 delta m+e，并且通过旋转我们得到了第一个系数为 m 的密文的多项式，也就成功提取出了 m。

我管这个含有不同 m 的可能取值的向量 V，所以我们只需要计算 V 乘上...当然这是第二步，我们要在第一部得到 delta m+e。但一个问题是在这里我们用的向量长度是 q，但实际运用时 q 是一个相当大的值，通常是...这里的一个向量实际上表达的是一个多项式，用这么大的多项式非常不可行。实际使用是我们会用更小的参数比如 2^10 次方。同时我们希望能够编码更小的值，所以实际操作时我们只会保留密文的高位，也就是明文信息，舍去低位噪音，也就是保留消息的同时将 q 变得更小。这也会让噪音增长一些。(modular switching)

现在我们知道了怎样进行取整，现在回到第一步，如何计算 delta m+e。还记得 delta m+e 等于 b-as，展开之后就是...我们希望同态的计算 delta m+e，a 和 b 都是已知的因为他们都是密文的一部分。s 作为密钥不知道。我们将会以自举密钥的形式提供他们的 RGSW 密文，所以 s 的每一个 bit 都被加密为 RGSW 密文。所以里面的明文是 0 和 1。自举过程首先设置和上面第二步一样的冗余向量 V，然后计算 b 位置的旋转，所以我们获得了 b，然后我们一个一个的加上 as，因为 s 是 0 或者 1 的密文，进行这个操作意味着选择输出指数是 0 或者是 1。我们之前也见过类似的操作，在盲转里面。所以我们跟之前一样的操作，因为 s 是 0 或者 1 的密文，根据他的值我们将选择输出 V0。最终逻辑上我们将输出 V0...于是我们得到了第二部分，然后迭代进行同样的操作直到获得 Vn-1...只需要将多个 CMux 门串联在一起就可以了。最终的结果就是我们期望的 VX...所以第一步我们也完成了。

两步连起来总结一下，自举输入一个 m 的 LWE 密文，然后计算这样的一个和盲转，也就是对输入向量的 delta m+e 位置进行旋转，目的是把复数个的 m 的密文旋转到第一个位置。但是最终我们希望获得的是一个 LWE 密文而不是一个 RingLWE 密文。所以我们怎样把 RingLWE 密文的一个系数提取出来，只需要进行一次采样提取，所以我们采样提取了多项式的第一个参数，也就是 m 的密文。经过这样的步骤我们获得了 m 的密文，但是他的噪音更小了。所以自举的目的达成了。我们可以看到自举前后的密钥是不一样的。输入的密文对应的密钥是 s，而输出的是 s'。如果我们想要把密钥变回 s 也只需要一次密钥变换就可以了。

这就是 bootstrap 在 TFHE 实现的大致思想。但实际上除了单纯降低噪音，他还可以执行更多功能。自举是可编程的，可以在降低噪音的同时计算一个特定函数。方法是将自举最开始使用的向量 V 的每个元素变为想要执行的函数。之前是 delta 个的 0，1...我们将其变换为 f(0)，f(1)...在实际操作中，我们在这个向量 V 里对所有可能的输入做了一个查找表的操作(look up table evaluation)，然后就像之前一样将这个向量输入进自举，然后盲转就会将 f(m) 放在开头，然后我们就能够得到 f(m)。所以我们实际上对 m 进行了一次 f 的变换。同时降低了噪音。

最后一张幻灯片总结了所有东西，我们有三种密文，LWE 可以进行自举，自举可以降低噪音，这里用虚线箭头表示。TFHE 还有一种自举叫做电路自举，也是用上面说的自举方式实现的，只不过稍微有一点复杂。能使我们从 LWE 到 RLWE 的同时降低噪音。如果我们把所有的组成单元都加回来，我们可以在各种密文之间自由变换。通过这些组成单元我们可以实现很多很多操作，构造所有想构造的东西。
