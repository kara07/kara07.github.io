---
layout:          post
title:           "Fully H0M0morphic Encryption II"
subtitle:        "十分难顶，甚至有九分。"
date:            2022-09-12 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

其实是一个 [TFHE](https://eprint.iacr.org/2018/421.pdf) 学习小记。非常感谢作者 Ilaria Chillotti 的讲解和 [FHE_org](https://www.youtube.com/watch?v=npoHSR6-oRw) 让我这种笨比也有机会领会这么高级的 FHE 方案。

组织了五个章节。首先咱简单讲讲关于全同态的一些常识，比如什么是全同态加密。然后深入讲解一下 TFHE。主要介绍 TFHE 所用到的密文。然后讲解一下使用这几种密文的构成单元(building blocks)和使用这些构成单元所能进行的混合操作。然后是如何进行自举(bootstrapping)。最后讲讲相关的实现和应用。

# FHE

## 什么是 FHE

FHE 所实现的功能概括来讲就是将密文的操作权和所有权分开。

比如这张图里面密文是 $x$，用一个带锁的蓝色盒子表示对其加密。所以一个带锁的蓝色盒子和里面的明文就表示了其密文。FHE 允许咱对密文执行对应操作，最简单的就是加操作，对应逻辑电路里的 XOR。比如有 $x$ 的密文和 $y$ 的密文，我们对密文进行加操作，结果将是一个新的密文对应明文 $x+y$。乘法也是一样对应 AND，我们对 $x$ 的密文和 $y$ 的密文进行乘操作将会得到 $x\times y$ 的密文。需要注意的一点是对密文空间的操作标成了黄色，而对明文空间的操作标成了红色。原因是对密文空间的操作将会比对明文空间的加和乘更为复杂。后面将会看到在 TFHE 中是怎样实现的。

FHE 意味着全同态，我们希望能够对任意由加法和乘法所组成的函数能够没有任何限制的执行。同时我们希望对明文也没有任何限制，我们希望可以加密bit,integer,real messages。我们也希望能够实现secret key,public key~~对称非对称~~两种加密模式。但在本文中我将会关注对称模式，因为不同于传统的密码学体系在全同态下对称和非对称加密体系实际上是等价的。一个非对称的加密体系可以由对称体系很容易得到(~~通过密钥派生~~)。

FHE 在云服务场景下非常有价值，我们的隐私将会得到充分的保护。比如有一个云服务提供商，它提供了非常有用的数据计算服务，但现实生活中的很多敏感数据不想让这些隐私被云服务商以及监听信道的第三者得到，就需要借助密码学将其加密上传给云。如果使用全同态加密，云服务提供商在无法获知数据内容的情况下也可以对加密的数据进行计算服务，数据的整个生命周期内都是加密的状态，只有数据拥有者才能够得知数据信息，并且不存在数据泄漏，因为就算有黑客攻破了云服务器，数据也同样是加密的。服务器端的限制也将会更小，服务器可以设在世界各地，即使每个地区的隐私政策都是不同的。

假设你是个计算机视觉的苦逼研究生(~~假设不需要这个假设~~)，买不起非常高级的设备，必须要借助云炼丹服务来完成自己的科研，这时候你肯定不希望自己的数据集，自己炼的模型被云服务提供商或是其他第三方剽窃，这时候就可以借助全同态，将加密的数据集和代码上传至云计算服务器，经过神经网络在加密的数据上进行计算返回给你加密的模型，然后再用你自己的密钥进行解密。云在不知道你上传的数据的情况下帮你炼了丹。

FHE可能会在未来改变英特网的工作模式，$HTTPS\to HTTPZ$，默认使用全同态加密协议与服务器建立连接，服务器将不会得知你发送的任何敏感数据比如电话号码，位置，ip，密码，且仍能够为你提供服务(~~现阶段只是一种设想~~)。

但是，~~古尔丹~~，代价是什么呢？全同态加密过程中的代价主要是一些咱称之为噪音的随机数。之前一张图里展示了对密文进行加操作和乘操作的过程，实际上当我们对明文进行一次加密之后就已经加入了一定的噪音。噪音实际上就是确保密码学功能安全的随机数，我们需要密码学功能是概率性的，所以我们至少在现在没办法取消他们。这里用密文右上方的温度计表示噪音程度。最开始噪音程度很低，但当我们进行同态的加或者乘操作之后噪音会变大。特别是进行乘操作之后噪音会比加操作更大。这实际上是一个痛点，因为如果噪音大小超过临界值，也就是温度计上的红线，将有概率无法正确解密。这一点是让全同态在 2009 年之前无法实现的原因之一。

## bootstrapping[[Gen09](http://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf)]

2009年，Gentry 用了一个很巧妙的方法 ，我把它翻译成自举(bootstrapping)。自举功能就是在噪音即将突破临界值时处理噪音。先简单介绍下，后面会详细讲讲 TFHE 的自举。

自举的思想是：当你有了一个密文 $x$，它的噪音即将突破临界值，这意味着我们将无法对其进行任何同态操作。所以只能停止，或者想办法降低它的噪音。最简单的降低噪音的方式就是对它解密，解密意味着把明文从盒子里拿出来，那么噪音也将不复存在。但解密需要密钥，同时密钥又不能交给云或者其他第三方来刷新噪音，不然我们对它加密还有什么意义。

Gentry 的方法是直接保留这个噪音很大的密文，就是这个蓝盒子，然后再把它放在一个绿盒子里。这个绿盒子是再一次的全同态加密。把蓝盒子放在绿盒子里面也不会改变任何蓝盒子的噪音。但由于这是一次全同态加密，绿盒子也会如温度计所示的带有一定的噪音，现在我们要做的是打开绿盒子里面的蓝盒子，也就是对蓝盒子解密。打开蓝盒子需要蓝色的钥匙。所以我们就给他蓝色的钥匙，但是得把它装在绿盒子里。我们将这个密文叫做自举密钥(bootstrapping key)，这是一个公开密钥，并且不会暴露我们手上的密钥信息。现在我们有一个装在绿盒子里的蓝盒子和一个装载绿盒子里的蓝钥匙，我们可以同态解密打开蓝盒子，结果将会得到一个绿盒子对明文的加密。如果看到这个绿色的温度计，它确实比之前会上升一点，但距离临界值还有一定的空间，这允许我们进行进一步的全同态操作。在实际操作中我们可以在进行同态操作之后尽快的自举，这样就会有一定的空间可以在临界值之前进行一些的操作，然后又回到自举开始之前。所以通过链式的不断自举我们可以构造任何电路，不会再有操作次数的限制。

## 两条支线

尽管自举是一个非常有用的技术，但它是全同态加密过程中开销最大的操作。所以又有不同的声音，我们在构造全同态加密的时候真的需要一直自举吗？答案是具体问题具体分析。如果你想同态(~~我翻成~~)计算(evaluate)的电路很小，并且你对他的构造很清楚，这意味着你知道要对它进行多少次同态操作，那我们对他采取(~~我翻成~~)精准的方法(leveled approach)，如果电路很大，并且你作为生成密钥的人不知道它的构造，那么我们就采用自举方法(bootstrapped approch)。

精准方法指尽可能避免自举，在进行同态计算之前必须知道要进行多少次操作，然后得固定参数以适应你要执行的操作数，使噪音控制在可接受的范围内。当然电路越大，参数设置的越大，密码学的操作将会变得更慢，所以越多的操作要执行，开销也会越大。

如果你想要更加灵活的或者是电路未知，这时候可以用自举方法，这样对操作次数就没有限制，需要不断对电路进行自举。

## 时间线

所以我们是怎么使用全同态的，是用一种方法还是两种都用？我将会用一条高度概括的时间线解释，只会列出一些代表性的文章。第一次提出实在 1978 年，然而这个问题非常难，经过 30 年也没有找到一个解决方法，这段时间诞生的方案被称为部分同态方案，可能是只有加或者乘的同态，也可能是能同时进行加和乘运算，但存在限制。直到 2009 年 Gentry 提出了自举和可以用理想格构造全同态之后学者们提出了很多很棒的成果。2010 年提出了 DGHV，是一个基于格上的 Approximate-GCD 问题在整数上进行操作的方案。虽然没有被用到现在，但是是一个很直观的方案。非常适合解释什么是全同态。然后在 2011 年，第一个基于 LWE 困难问题的 FHE 方案被提出，叫做 BGV。LWE 是一个格上的平均情况计算困难问题，拥有很多传统困难问题所不具备的优越性。之前也讲过比如抗量子计算攻击，存在最环情况到平均情况的归约，能够构建很多高级密码学功能比如安全的多线性映射等等。之后在 2012 年，另外一个基于也是格问题的 NTRU 的分支被提出，虽然在今天可能面临一些重大的安全性问题，但也是很好的方案。2013 年我们有了另一个基于 LWE 的方案叫做 GSW 方案。现在所更为充分研究的就是基于 LWE 问题的分支，也就是 BGV 和 GSW 分支。BGV 在 2012 年有一个变体叫 BFV，GSW 在 2014 年的变体叫 FHEW，提出了一种非常快的基于 GSW 的自举方法。所以延续到至今的有主要有两个分支，一个是 BGV 分支，更加偏向于精确的方案，避免使用开销大的自举，以及 GSW 分支使用更快的自举，允许我们尽情使用自举。BGV 分支后来有了 CKKS，是一个使用至今的著名方案，同时在 GSW 分支有了 TFHE，也就是这次要讲的。TFHW 最开始是对 FHEW 的提升，之后发展出了很多功能。如果看过这两条支线的构造就会发现实际上这两条直线之间的差别比想象的要小。比如 [BGGJ19] 提出了一种通用框架使得 TFHE 和 HEAAN[CKKS17]可以同时工作，或者说可以很简单的变换到另一种方案。

# TFHE

现在让我们抛开一些技术细节简单的看一看 TFHE 方案。如果对代数和格计算问题不是那么熟悉也没关系，这里我会讲的尽可能简单，讲完整个方案构造之后才会涉及到技术细节。

## TFHE 密文

### LWE

首先从 TFHE 的密文开始。TFHE 里一共有三种密文，第一种叫 LWE。LWE 就是格上的一个困难问题，我们用这个问题来来加密明文。LWE 密文用来加密一个消息，可以是一个比特，一个模整数，一个特定区间内的实数。密钥是一个由短向量，每个元素都是一个比特，可以看成是随机比特。是否用比特不是强制的，也可以用其他类型的密钥，比如 LWE 问题常用的 ternary keys，i.e.，$\qty{-1,0,1}$,gaussian keys。这里我将重点关注比特密钥。

密文由 $n+1$ 个元素组成，前 $n$ 个元素是向量 $a$，最后一个元素是 $b$。$a\_i$ 均匀随机的在 $\mathbb{Z}\_q$ 中选取，也就是模 $q$ 整数。最后一个元素 $b$ 由所有 $a$ 元素和密钥的乘积组成，然后再加上特定的噪音 $e$，和密文和标量 $\Delta$ 的乘积。这里的噪音 $e$ 就是一个服从特定分布，一般是离散高斯分布的噪音。所以均匀随机的 $a$，乘上密钥的随机元素，然后加上噪音，和消息，然后得到了 $b$

解密时我们知道密钥，直接计算 $b-\mathbf{a}\mathbf{s}$ 这将会得到 $\Delta m+e$，然后我们直接进行取整，或者叫舍入，就得到了 $m$。

取整是一个非常简单的操作，通过这张图就能很好理解。这张图只是一个可视化的直观的很简单的例子，并不是真正使用时的参数。当我们对 $q$ 取模时，就像用了一个离散的转盘(Torus)一样。转盘就是这个圆圈，0 在底部，逆时针依次增大，1,2,3 一直到61,62,63，$q=64$，所以当我们数到 64 就又回到了0。这就是模 $q$ 的思想。如果我们设定 $q$ 等于 64，那么我们可以使用最多 6 bit 的密文。然后选一个 p，p 是我们想要加密的明文的数量，在这个简单例子里是 4 个元素。这意味着我们有两个 bit 的明文信息。$\Delta$ 则是 $q$ 和 p 的比。为了可视化的表示，p 是我们可以加密的明文的数量，只有这四个元素里面一个消息能够加密到密文里面。也就是我们有四种选择。因为有四种选择，所以有两个 bit 可以表示他们。我们将把它加密到密文的最高位 bit。$\Delta$ 在这里表示了这个转盘上的一个消息和第二个之间的距离。所以消息将会被分散开 $\Delta$ 距离。之前说过我们要计算 $\Delta m+e$，噪音的大小必须被限制。它被限制为 $\Delta/2$。在加密过程中我们把噪音放在密文的最低位 bit。在这个转盘里红色的线表示对特定密文添加的噪音的范围，不能超过这条红色的线。

我们给出一个非常简单的例子。比如我们想对 3 加密，3 将被编码为 $\Delta m$ 在这个例子里等于 48，在转盘的这个地方。在密文的最高位编码了二进制的 3，然后我们加上一些噪音等于 5，它被编码到密文的最低位，最终密文得到了对 53 的加密。53 在转盘的这里。当你像这样解密时，先算 $b-\mathbf{a}\mathbf{s}$ 然后得到了 $\Delta m+e$，知道 $\Delta m+e$ 恢复出 $m$ 非常简单，只需要对 $\Delta m+e$ 取整到最近的可能消息，也就是 $\Delt了知道 $\Delta m$ 恢复出 $m$ 就很直接了。之前我也说过这只是一个迷你例子，真正用到的 $q$ 不会是 64，而是 $2^32,2^64$ 之类的大数。这些是我们在使用 TFHE 时常用的参数。

我们在讨论全同态加密，所以我们希望一些全同态的操作。用 LWE 可以实现加法，你可以直接把两个 a 部分和 b 部分进行相加来把两个密文加在一起，然后结果会变为第一个明文和第二个明文的密文。在这之上拓展也可以实现整数的数乘，只需要直接对 a 和 b 分别数乘就可以了，就会得到对应明文的数乘。但很遗憾我们不能对这两个密文进行相乘，乘法运算会在之后的部分用其他密文实现。

LWE 是第一种密文类型，第二种是 RLWE。RLWE 不只可以加密一条信息，他可以加密一个含有许多系数的多项式，每一个系数都是一个 LWE 里的消息，所以他可以是一个比特，一个整数或者是实数。所以我们加密的是一个多项式，每个多项式都有 N 个系数。我们选取的密钥也不再是一个向量而是一个多项式，含有系数这里是一个 bit。这同样也不是强制的，密钥可以是 ternary，gaussian。但在这里我们还是只关注二进制的。密文用一种跟 LWE 非常相似的方式进行加密。所以你有 A 部分和 B 部分。A 和 B 这次代表多项式。A 多项式也是均匀随机的，所以这里所有的整数都是随机的模 q 整数，B 部分和之前构建的方式一样，只是现在我们在对多项式进行计算，所以我们现在用 A 乘 S 加上一个噪音，一个高斯分布的噪音，然后加上 delta 乘上消息。只是现在并非是一个标量，而是一个多项式。

解密的方式也是一样，如果你知道密钥，就直接算 b-as，然后结果就是 delta m+e，最后对他取整得到消息 m。

所以跟之前一样，知道 delta m+e 能够简单的恢复出 m。就使用我们之前用过的方式。只不过我们现在不是只有一个转盘，而是对于多项式的每一个系数都有一个转盘。所以只要知道之前我们是怎么做的，这里就只需要重复 n 次就可以了。

同样的我们可以实现加法和数乘，乘上一个整数多项式的常量。计算过程和之前相同，加法就直接将密文的 A 和 B 相加，数乘则是将 A 和 B 都乘上一个整数多项式。然后会得到多项式 gamma 乘 m 的密文。

最后一种密文，同时也是最重要的，是 RingGSW 跟 RingLWE 类似，它将对一个有 N 个系数的多项式进行加密，密钥和 RingLWE 的密钥一样，所以是一个系数是 0 和 1 的多项式。但是现在密文将会更加复杂一点，我们将会用一个三维的矩阵表示它，这个矩阵在不同深度有很多层，总共有 l 层，在前面的每一层都由四个多项式组成，第一行有两个，第二行有两个，每一个多项式都是一个 RLWE 的密文，也就是之前我们见过的第二种密文里的。第一行我们对消息 mu 乘上密钥乘上固定的 betaj分之 q，j 从 1 取到 l。在第二行我们对消息 mu 乘上 betaj 分之 q，这里没有密钥 s。上下都有 mu 乘上 betaj 分之 q，只不过上面多乘一个密钥 S。

这个看上去比之前的都要复杂一点，但这个结构允许我们对他进行更多的操作。所以我们可以做加运算，可以做乘上一个常量多项式，方法也跟之前一样，分别对 A 和 B 部分相加，或者对其乘上一个常量多项式。但现在我们可以同样实现乘法运算，这是前面两种密文所做不到的。

乘运算是怎么实现的？乘运算并没有那么直观，并不是很难，但并不是很直观。现在有两个密文一个加密了 mu，一个加密了 mu' 然后你想计算这两个密文。这样的乘法运算由两个步骤实现。第一步我翻译成解构(decomposition)。首先给第一个密文拎出来，首先只看这个密文的一层，也就是一个 2x2 的矩阵。其他层也是一样的执行。要做的是解构每一个多项式为特数量的小多项式。这里也就是 l 个小多项式。这里的 Aj 将会被解构为这 l 个小多项式，Bj 则是这 l 个小多项式，依次类推。解构是一个很容易实现的操作，并且运算速度很快。然后是第二步，第二步就是矩阵乘法。将第一步解构得到的小多项式乘上第二个密文。这个乘法就是矩阵点乘，将对应的多项式的积求和。然后得到一个输出的多项式，也就是输出的密文。所以如果对密文的每一层都重复相同的操作，就能够得到对应的输出的所有层的结果。输出的密文代表了mu和mu'的乘积。虽然看上去是一个很复杂的操作，但实际上很好去实现。

接下来是这个部分的最后一张幻灯片，是一个总结，总结了我们到目前干了些什么。我们有三种类型的密文，LWE,RLWE 和 RGSW。LWE 有一个向量和一个元素 b 组成，能进行加和数乘运算。RLWE 由两个多项式组成，同样能进行加和数乘运算。RGSW 稍微复杂一点，由一个三维的矩阵组成，但同时可以进行加，数乘以及乘法运算。


# 组成单元和混合操作

现在我们要把这些密文组合在一起。第一个操作是(~~我翻译成~~)外积(external product)。虽然它叫外积，但是他的运算是内积。它跟 RingGSW 密文的乘法非常类似，但比他更简单。叫做外积是因为它是两个不同元素之间的乘法，RingLWE 和 RingGSW。这两种不同的密文进行乘法的结果是一个 RLWE 密文。并且其对应的明文是 mu 和 M 的乘积。在操作上跟 RingGSW 非常类似，首先对 RLWE 密文进行解构，同样的 A 元素被解构成一系列小多项式，B元素也同样。然后第二步将进行解构出来的矩阵跟矩阵的点乘。外积运算比乘法更快。

外积运算非常重要，通过他可以定义另一种组成单元叫做 CMux，意思是 Controlled MUX，可控制的数据选择器？MUX 门如图所示，输入三个元素，b,d0,d1。取决于输入 b 是 0 还是 1，它选择输出 d0 或者是 d1。所以如果 b 等于 1，它就输出 d1，b 等于 0，它就输出 d0。所以这个门电路的功能可以用这个逻辑表达式表示。如果 b 等于 0，前面一项就没了，只剩下 d0，如果 b 等于 1，就只剩下 d1。这个门电路的实际功能等同于 if 控制语句，如何同态的实现他呢？
这个元件非常有用，在后面的构造尤其是自举里面会用到非常多。所以希望大家好好记住它。

第一个组成单元是旋转(Rotation)。我将会由简到难的介绍这个功能。我们先从明文开始。如果我想旋转这个多项式到p位置。M 是这个多项式，M0+M1+++，因为我们在 mod XN+1 上进行操作。我们想要获得的是系数 Mp。所以我们得旋转这个多项式使 Mp 旋转到第一个。操作非常简单，只需要对这个多项式乘上 X-P 次方，然后 Mp 就成了多项式的第一个系数，也就是 X 的 0 次方，常数项的系数。其他后面系数跟在他后面，它前面的系数将会在多项式最后系数变为负数，因为我们在 mod XN+1 上进行操作。所以这个操作很简单，只需要乘上 X-p 就行了。

现在增大一点难度对 M 的密文的 p 位置进行旋转。所以 M 是加密后的，p 已知。M将会用 RingLWE 加密，也就是橙色的密文。密文和常多项式的乘法之前讲过很简单，只需要对 A 部分和 B 部分对应相乘就行了。结果将会是 M 乘 X-P 的 RLWE 密文。也就是旋转过后的 M 的密文。所以同样也很简单，这个操作没有增加任何噪音。

但再难一点，不只是 M 加密了，位置 p 也加密了。也就是我们想要去获得的系数的位置也被加密了。我们先将 p 表示为二进制数，分别是 p0,p1,pk，假设这些二进制数以 RGSW 密文的形式提供。也就是说这 p 个元素未知，他们都是密文，2^j 是一个常量，当然知道。现在我们想要计算的是 M 乘上 X-P 来进行旋转。M 乘上 X-P 可以写成这样的二进制形式，他就等于...让我们关注其中的一项...我们直接计算...再重申一遍 M 是加密的 p 也是加密的，所以让看一下我们想得到怎样的输出。如果 p 等于 0 指数就是 0，这一项就变成了 1，输出将会变成 M。所以如果 pj 是 0，我们将得到输出的 M；如果 pj 等于 1，指数将会变成 2j，所以我们将得到输出的结果是 X 的 2j 次方。所以可能大家已经懂了，这是一个 if 条件判断，我们实现 if 的方式就是用上面提到的CMux。在这里 CMux 0 端输入 M 的密文，在对应 1 端输入 M 的密文乘上明文的...然后通过选择器 pj 的密文进行判断。输出结果是...也就是我们想得到的。

如果这一步清楚了，对整个 p 进行操作只需要构造一个 CMux 门组成的链。所以我们由 0 开始，输入密文...你将会得到一个密文 M0，他的值是...然后吧 M0 作为输入，传递到下一个 CMux 门，然后你将会得到 M1，然后一直下去最终得到 M 乘 X-P。

所以我们可以通过这种方式实现盲转，也就是对未知的多项式的未知位置进行旋转。

这个可能是最难的构造单元，后面的会简单很多。下一个是采样提取器，他输入一个 RLWE 密文，加密的是多项式 Mx，他的构造方式前面已经看过了，然后你想要把多项式 M 的系数提取出来。这意味着你不知道 M，但你想得到他的一个系数，作为 LWE 密文。这里以 M0 做例子。这个很简单，只需要以特定顺序重新排列 M，然后复制输出的 LWE 密钥为对应 RLWE 密钥的系数向量。这个操作不会增大噪音，只需要重新排列 M 的系数就可以了，当然不只是 M0 可以被提取出来，任何一个系数都可以被提取出来，只需要以合适的方式重新排列输出的系数。

最后一个也很重要，是密钥更换。假设你有一个输入的 m 的密文，其对应的密钥是 s，你想要输出一个同样是 m 的密文，其密钥是 s'，这个操作需要一个密钥叫做密钥更换密钥，是一个公钥，跟后面会提到的自举的密钥非常相似。不只是可以交换密钥，也可以更换参数，如果你想要更换参数，也可以通过这个操作。


# 技术细节





TFHE实际上提供了一个更高效的 FHE 的砖块：一个自举的 NAND 门。NAND门具有 Functional Completeness，这意味着可以只用 NAND 门构造任何电路。同时由于全同态加密会在每一步操作之后造成噪音的累积，自举的 NAND 门可以在每一次执行 NAND 时刷新噪音。所以这确实是一个实用的砖块，能够用他构造任何全同态方案。

这篇文章实际介绍了两种 TFHE，分别对应上文两条支线的自举方案[CGGI16]和精确方案[CGGI17]。在之后介绍自举方法时会有所区分。

第一个问题是为什么叫TFHE。FHE 代表全同态加密，T则代表 Torus。方案定义了一种代数结构叫 Torus。我们用到是实数 Torus。

$$\mathbb{T}=\mathbb{R}/\mathbb{Z}=\mathbb{R}\bmod 1$$

所有模 1 实数。如果定义了加法和整数环上的数乘，$(\mathbb{T},+,\cdot)$，Torus 就是一个很好的 $\mathbb{Z}$-模。模结构和线性空间很类似，在加法上是一个交换群，这说明如果我们拿两个 Torus 元素，我们可以把它加在一起，加法可以被定义；我们也进行数乘运算，如同线性空间里的标量乘一样。如果拿一个蓝色的 Torus 元素和一个红色的整数环的元素，对他们俩进行数乘结果是一个 Torus 元素。数乘也是可以被定义的。但它并没有环的结构，这意味着乘运算没有被很好的定义。

有了 $\mathbb{Z}$-模的属性之后，可以非常简单的将其拓展到多项式。这里用 $\mathbb{T}\_N\bqty{X}$ 表示系数在 Torus 里的多项式，也就是系数为模 1 实数的多项式，模上多项式 $x^N+1$。然后 $(\mathbb{T}\_N\bqty{X},+,\cdot)$ 是 $\mathfrak{R}$ 上的模，$\mathfrak{R}$ 是 Ring-LWE 里用到的整数多项式模 $X^N+1$。同样我们可以在 Torus 多项式上进行加法和整数多项式的数乘，但两个 Torus 多项式之间的乘法没有定义。

上面的对这个代数结构的介绍，如果对代数不太熟悉也没有关系，


个人感觉咱可以这样利用一个高性能(~~逼格~~)的全同态方案，难度从易到难排序：

1. 拿来主义。直接将这个方案用在相关领域。毕竟是全同态，可以运用在几乎每一种场景。
2. extanded TFHE。在原方案或者其他方案的基础上类似方案的功能，实现一些原方案所不具有的功能。比如 [MK-TFHE](https://scholar.google.com/citations?view_op=view_citation&hl=en&user=w_OlJw8AAAAJ&citation_for_view=w_OlJw8AAAAJ:Y0pCki6q_DkC)
3. 全同态领域的创新。比如 TFHE 比起 FHEW 就提出了使用一种代数结构 TORUS 进行操作。