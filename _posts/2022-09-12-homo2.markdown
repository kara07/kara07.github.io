---
layout:          post
title:           "Fully H0M0morphic Encryption II"
subtitle:        "十分难顶，甚至有九分。"
date:            2022-09-12 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

稿子记一记，免得講论文时脑子抽筋。

组织了五个章节。首先咱简单讲讲全同态加密的一些常识，比如什么是 FHE。然后深入讲一下 TFHE。主要介绍 TFHE 所用到的密文。然后讲解一下使用这几种密文的构成单元(building blocks)和使用这些构成单元所能进行的混合操作。接着是如何进行自举(bootstrapping)。最后讲讲相关的实现和应用。

# FHE

## 什么是 FHE

FHE 所实现的功能概括来讲就是将密文的操作权和所有权分开。

比如这张图里的明文 $x$，用一个带锁的蓝色盒子表示对其加密。所以一个带锁的蓝色盒子和里面的明文就表示了其密文。FHE 允许咱对密文执行对应操作，最简单的就是加操作，对应逻辑电路里的 XOR。比如有 $x$ 的密文和 $y$ 的密文，我们对密文进行加操作，结果将是一个新的密文对应明文 $x+y$。乘法也是一样对应 AND，我们对 $x$ 的密文和 $y$ 的密文进行乘操作将会得到 $x\times y$ 的密文。需要注意的一点是对密文空间的操作标成了黄色，而对明文空间的操作标成了红色。原因是对密文空间的操作将会比对明文空间的加和乘更为复杂。后面将会看到在 TFHE 中是怎样实现的。

FHE 意味着全同态，我们希望能够对任意由加法和乘法所组成的函数能够没有任何限制的执行。同时我们希望对明文也没有任何限制，我们希望可以加密bit,integer,real messages。我们也希望能够实现secret key,public key~~对称非对称~~两种加密模式。但在本文中我将会关注对称模式，因为不同于传统的密码学体系在全同态下对称和非对称加密体系实际上是等价的。一个非对称的加密体系可以由对称体系很容易得到(~~通过密钥派生~~)。

FHE 在云服务场景下非常有价值，我们的隐私将会得到充分的保护。比如有一个云服务提供商，它提供了非常有用的数据计算服务，但现实生活中的很多敏感数据不想让这些隐私被云服务商以及监听信道的第三者得到，就需要借助密码学将其加密上传给云。如果使用全同态加密，云服务提供商在无法获知数据内容的情况下也可以对加密的数据进行计算服务，数据的整个生命周期内都是加密的状态，只有数据拥有者才能够得知数据信息，并且不存在数据泄漏，因为就算有黑客攻破了云服务器，数据也同样是加密的。服务器端的限制也将会更小，服务器可以设在世界各地，即使每个地区的隐私政策都是不同的。

假设你是个计算机视觉的苦逼研究生(~~假设不需要这个假设~~)，买不起非常高级的设备，必须要借助云炼丹服务来完成自己的科研，这时候你肯定不希望自己的数据集，自己炼的模型被云服务提供商或是其他第三方剽窃，这时候就可以借助全同态，将加密的数据集和代码上传至云计算服务器，经过神经网络在加密的数据上进行计算返回给你加密的模型，然后再用你自己的密钥进行解密。云在不知道你上传的数据的情况下帮你炼了丹。

FHE可能会在未来改变英特网的工作模式，$HTTPS\to HTTPZ$，默认使用全同态加密协议与服务器建立连接，服务器将不会得知你发送的任何敏感数据比如电话号码，位置，ip，密码，且仍能够为你提供服务(~~现阶段只是一种设想~~)。

但是，~~古尔丹~~，代价是什么呢？全同态加密过程中的代价主要是一些咱称之为噪音的随机数。之前一张图里展示了对密文进行加操作和乘操作的过程，实际上当我们对明文进行一次加密之后就已经加入了一定的噪音。噪音实际上就是确保密码学功能安全的随机数，我们需要密码学功能是概率性的，所以我们至少在现在没办法取消他们。这里用密文右上方的温度计表示噪音程度。最开始噪音程度很低，但当我们进行同态的加或者乘操作之后噪音会变大。特别是进行乘操作之后噪音会比加操作更大。这实际上是一个痛点，因为如果噪音大小超过临界值，也就是温度计上的红线，将有概率无法正确解密。这一点是让全同态在 2009 年之前无法实现的原因之一。

## bootstrapping[[Gen09](http://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf)]

2009年，Gentry 用了一个很巧妙的方法 ，我把它翻译成自举(bootstrapping)。自举功能就是在噪音即将突破临界值时处理噪音。先简单介绍下，后面会详细讲讲 TFHE 的自举。

自举的思想是：当你有了一个密文 $x$，它的噪音即将突破临界值，这意味着我们将无法对其进行任何同态操作。所以只能停止，或者想办法降低它的噪音。最简单的降低噪音的方式就是对它解密，解密意味着把明文从盒子里拿出来，那么噪音也将不复存在。但解密需要密钥，同时密钥又不能交给云或者其他第三方来刷新噪音，不然我们对它加密还有什么意义。

Gentry 的方法是直接保留这个噪音很大的密文，就是这个蓝盒子，然后再把它放在一个绿盒子里。这个绿盒子是再一次的全同态加密。把蓝盒子放在绿盒子里面也不会改变任何蓝盒子的噪音。但由于这是一次全同态加密，绿盒子也会如温度计所示的带有一定的噪音，现在我们要做的是打开绿盒子里面的蓝盒子，也就是对蓝盒子解密。打开蓝盒子需要蓝色的钥匙。所以我们就给他蓝色的钥匙，但是得把它装在绿盒子里。我们将这个密文叫做自举密钥(bootstrapping key)，这是一个公开密钥，并且不会暴露我们手上的密钥信息。现在我们有一个装在绿盒子里的蓝盒子和一个装载绿盒子里的蓝钥匙，我们可以同态解密打开蓝盒子，结果将会得到一个绿盒子对明文的加密。如果看到这个绿色的温度计，它确实比之前会上升一点，但距离临界值还有一定的空间，这允许我们进行进一步的全同态操作。在实际操作中我们可以在进行同态操作之后尽快的自举，这样就会有一定的空间可以在临界值之前进行一些的操作，然后又回到自举开始之前。所以通过链式的不断自举我们可以构造任何电路，不会再有操作次数的限制。

## 两条支线

尽管自举是一个非常有用的技术，但它是全同态加密过程中开销最大的操作。所以又有不同的声音，我们在构造全同态加密的时候真的需要一直自举吗？答案是具体问题具体分析。如果你想同态(~~我翻成~~)计算(evaluate)的电路很小，并且你对他的构造很清楚，这意味着你知道要对它进行多少次同态操作，那我们对他采取(~~我翻成~~)精准的方法(leveled approach)，如果电路很大，并且你作为生成密钥的人不知道它的构造，那么我们就采用自举方法(bootstrapped approch)。

精准方法指尽可能避免自举，在进行同态计算之前必须知道要进行多少次操作，然后得固定参数以适应你要执行的操作数，使噪音控制在可接受的范围内。当然电路越大，参数设置的越大，密码学的操作将会变得更慢，所以越多的操作要执行，开销也会越大。

如果你想要更加灵活的或者是电路未知，这时候可以用自举方法，这样对操作次数就没有限制，需要不断对电路进行自举。

## 时间线

所以我们是怎么使用全同态的，是用一种方法还是两种都用？我将会用一条高度概括的时间线解释，只会列出一些代表性的文章。第一次提出实在 1978 年，然而这个问题非常难，经过 30 年也没有找到一个解决方法，这段时间诞生的方案被称为部分同态方案，可能是只有加或者乘的同态，也可能是能同时进行加和乘运算，但存在限制。直到 2009 年 Gentry 提出了自举和可以用理想格构造全同态之后学者们提出了很多很棒的成果。2010 年提出了 DGHV，是一个基于格上的 Approximate-GCD 问题在整数上进行操作的方案。虽然没有被用到现在，但是是一个很直观的方案。非常适合解释什么是全同态。然后在 2011 年，第一个基于 LWE 困难问题的 FHE 方案被提出，叫做 BGV。LWE 是一个格上的平均情况计算困难问题，拥有很多传统困难问题所不具备的优越性。之前也讲过比如抗量子计算攻击，存在最环情况到平均情况的归约，能够构建很多高级密码学功能比如安全的多线性映射等等。之后在 2012 年，另外一个基于也是格问题的 NTRU 的分支被提出，虽然在今天可能面临一些重大的安全性问题，但也是很好的方案。2013 年我们有了另一个基于 LWE 的方案叫做 GSW 方案。现在所更为充分研究的就是基于 LWE 问题的分支，也就是 BGV 和 GSW 分支。BGV 在 2012 年有一个变体叫 BFV，GSW 在 2014 年的变体叫 FHEW，提出了一种非常快的基于 GSW 的自举方法。所以延续到至今的有主要有两个分支，一个是 BGV 分支，更加偏向于精确的方案，避免使用开销大的自举，以及 GSW 分支使用更快的自举，允许我们尽情使用自举。BGV 分支后来有了 CKKS，是一个使用至今的著名方案，同时在 GSW 分支有了 TFHE，也就是这次要讲的。TFHW 最开始是对 FHEW 的提升，之后发展出了很多功能。如果看过这两条支线的构造就会发现实际上这两条直线之间的差别比想象的要小。比如 [BGGJ19] 提出了一种通用框架使得 TFHE 和 HEAAN[CKKS17]可以同时工作，或者说可以很简单的变换到另一种方案。

# TFHE

现在让我们抛开一些技术细节简单的看一看 TFHE 方案。如果对代数和格计算问题不是那么熟悉也没关系，这里我会讲的尽可能简单，讲完整个方案构造之后才会涉及到技术细节。

## TFHE 密文

### LWE

首先从 TFHE 的密文开始。TFHE 里一共有三种密文，第一种叫 LWE。LWE 就是格上的一个困难问题，我们用这个问题来来加密明文。LWE 密文用来加密一个消息，可以是一个比特，一个模整数，一个特定区间内的实数。密钥是一个由短向量，每个元素都是一个比特，可以看成是随机比特。是否用比特不是强制的，也可以用其他类型的密钥，比如 LWE 问题常用的 ternary keys，i.e.，$\qty{-1,0,1}$,gaussian keys。这里我将重点关注比特密钥。

密文由 $n+1$ 个元素组成，前 $n$ 个元素是向量 $a$，最后一个元素是 $b$。$a\_i$ 均匀随机的在 $\mathbb{Z}\_q$ 中选取，也就是模 $q$ 整数。最后一个元素 $b$ 由所有 $a$ 元素和密钥的乘积组成，然后再加上特定的噪音 $e$，和密文和标量 $\Delta$ 的乘积。这里的噪音 $e$ 就是一个服从特定分布，一般是离散高斯分布的噪音。所以均匀随机的 $a$，乘上密钥的随机元素，然后加上噪音，和消息，然后得到了 $b$

解密时我们知道密钥，直接计算 $b-\mathbf{a}\mathbf{s}$ 这将会得到 $\Delta m+e$，然后我们直接进行取整，或者叫舍入，就得到了 $m$。

取整是一个非常简单的操作，通过这张图就能很好理解。这张图只是一个可视化的直观的很简单的例子，并不是真正使用时的参数。当我们对 $q$ 取模时，就像用了一个离散的转盘(Torus)一样。转盘就是这个圆圈，0 在底部，逆时针依次增大，1,2,3 一直到61,62,63，$q=64$，所以当我们数到 64 就又回到了0。这就是模 $q$ 的思想。如果我们设定 $q$ 等于 64，那么我们可以使用最多 6 bit 的密文。然后选一个 p，p 是我们想要加密的明文的数量，在这个简单例子里是 4 个元素。这意味着我们有两个 bit 的明文信息。$\Delta$ 则是 $q$ 和 p 的比。为了可视化的表示，p 是我们可以加密的明文的数量，只有这四个元素里面一个消息能够加密到密文里面。也就是我们有四种选择。因为有四种选择，所以有两个 bit 可以表示他们。我们将把它加密到密文的最高位 bit。$\Delta$ 在这里表示了这个转盘上的一个消息和第二个之间的距离。所以消息将会被分散开 $\Delta$ 距离。之前说过我们要计算 $\Delta m+e$，噪音的大小必须被限制。它被限制为 $\Delta/2$。在加密过程中我们把噪音放在密文的最低位 bit。在这个转盘里红色的线表示对特定密文添加的噪音的范围，不能超过这条红色的线。

我们给出一个非常简单的例子。比如我们想对 3 加密，3 将被编码为 $\Delta m$ 在这个例子里等于 48，在转盘的这个地方。在密文的最高位编码了二进制的 3，然后我们加上一些噪音等于 5，它被编码到密文的最低位，最终密文得到了对 53 的加密。53 在转盘的这里。当你像这样解密时，先算 $b-\mathbf{a}\mathbf{s}$ 然后得到了 $\Delta m+e$，知道 $\Delta m+e$ 恢复出 $m$ 非常简单，只需要对 $\Delta m+e$ 取整到最近的可能消息，也就是 $\Delt了知道 $\Delta m$ 恢复出 $m$ 就很直接了。之前我也说过这只是一个迷你例子，真正用到的 $q$ 不会是 64，而是 $2^32,2^64$ 之类的大数。这些是我们在使用 TFHE 时常用的参数。

我们在讨论全同态加密，所以我们希望一些全同态的操作。用 LWE 可以实现加法，你可以直接把两个 a 部分和 b 部分进行相加来把两个密文加在一起，然后结果会变为第一个明文和第二个明文的密文。在这之上拓展也可以实现整数的数乘，只需要直接对 a 和 b 分别数乘就可以了，就会得到对应明文的数乘。但很遗憾我们不能对这两个密文进行相乘，乘法运算会在之后的部分用其他密文实现。

LWE 是第一种密文类型，第二种是 RLWE。RLWE 不只可以加密一条信息，他可以加密一个含有许多系数的多项式，每一个系数都是一个 LWE 里的消息，所以他可以是一个比特，一个整数或者是实数。所以我们加密的是一个多项式，每个多项式都有 N 个系数。我们选取的密钥也不再是一个向量而是一个多项式，含有系数这里是一个 bit。这同样也不是强制的，密钥可以是 ternary，gaussian。但在这里我们还是只关注二进制的。密文用一种跟 LWE 非常相似的方式进行加密。所以你有 A 部分和 B 部分。A 和 B 这次代表多项式。A 多项式也是均匀随机的，所以这里所有的整数都是随机的模 q 整数，B 部分和之前构建的方式一样，只是现在我们在对多项式进行计算，所以我们现在用 A 乘 S 加上一个噪音，一个高斯分布的噪音，然后加上 delta 乘上消息。只是现在并非是一个标量，而是一个多项式。

解密的方式也是一样，如果你知道密钥，就直接算 b-as，然后结果就是 delta m+e，最后对他取整得到消息 m。

所以跟之前一样，知道 delta m+e 能够简单的恢复出 m。就使用我们之前用过的方式。只不过我们现在不是只有一个转盘，而是对于多项式的每一个系数都有一个转盘。所以只要知道之前我们是怎么做的，这里就只需要重复 n 次就可以了。

同样的我们可以实现加法和数乘，乘上一个整数多项式的常量。计算过程和之前相同，加法就直接将密文的 A 和 B 相加，数乘则是将 A 和 B 都乘上一个整数多项式。然后会得到多项式 gamma 乘 m 的密文。

最后一种密文，同时也是最重要的，是 RingGSW 跟 RingLWE 类似，它将对一个有 N 个系数的多项式进行加密，密钥和 RingLWE 的密钥一样，所以是一个系数是 0 和 1 的多项式。但是现在密文将会更加复杂一点，我们将会用一个三维的矩阵表示它，这个矩阵在不同深度有很多层，总共有 l 层，在前面的每一层都由四个多项式组成，第一行有两个，第二行有两个，每一个多项式都是一个 RLWE 的密文，也就是之前我们见过的第二种密文里的。第一行我们对消息 mu 乘上密钥乘上固定的 betaj分之 q，j 从 1 取到 l。在第二行我们对消息 mu 乘上 betaj 分之 q，这里没有密钥 s。上下都有 mu 乘上 betaj 分之 q，只不过上面多乘一个密钥 S。

这个看上去比之前的都要复杂一点，但这个结构允许我们对他进行更多的操作。所以我们可以做加运算，可以做乘上一个常量多项式，方法也跟之前一样，分别对 A 和 B 部分相加，或者对其乘上一个常量多项式。但现在我们可以同样实现乘法运算，这是前面两种密文所做不到的。

乘运算是怎么实现的？乘运算并没有那么直观，并不是很难，但并不是很直观。现在有两个密文一个加密了 mu，一个加密了 mu' 然后你想计算这两个密文。这样的乘法运算由两个步骤实现。第一步我翻译成解构(decomposition)。首先给第一个密文拎出来，首先只看这个密文的一层，也就是一个 2x2 的矩阵。其他层也是一样的执行。要做的是解构每一个多项式为特数量的小多项式。这里也就是 l 个小多项式。这里的 Aj 将会被解构为这 l 个小多项式，Bj 则是这 l 个小多项式，依次类推。解构是一个很容易实现的操作，并且运算速度很快。然后是第二步，第二步就是矩阵乘法。将第一步解构得到的小多项式乘上第二个密文。这个乘法就是矩阵点乘，将对应的多项式的积求和。然后得到一个输出的多项式，也就是输出的密文。所以如果对密文的每一层都重复相同的操作，就能够得到对应的输出的所有层的结果。输出的密文代表了mu和mu'的乘积。虽然看上去是一个很复杂的操作，但实际上很好去实现。

接下来是这个部分的最后一张幻灯片，是一个总结，总结了我们到目前干了些什么。我们有三种类型的密文，LWE,RLWE 和 RGSW。LWE 有一个向量和一个元素 b 组成，能进行加和数乘运算。RLWE 由两个多项式组成，同样能进行加和数乘运算。RGSW 稍微复杂一点，由一个三维的矩阵组成，但同时可以进行加，数乘以及乘法运算。

# 组成单元和混合操作

现在我们要把这些密文组合在一起。第一个操作是(~~我翻译成~~)外积(external product)。虽然它叫外积，但是他的运算是内积。它跟 RingGSW 密文的乘法非常类似，但比他更简单。叫做外积是因为它是两个不同元素之间的乘法，RingLWE 和 RingGSW。这两种不同的密文进行乘法的结果是一个 RLWE 密文。并且其对应的明文是 mu 和 M 的乘积。在操作上跟 RingGSW 非常类似，首先对 RLWE 密文进行解构，同样的 A 元素被解构成一系列小多项式，B元素也同样。然后第二步将进行解构出来的矩阵跟矩阵的点乘。外积运算比乘法更快。

外积运算非常重要，通过他可以定义另一种组成单元叫做 CMux，意思是 Controlled MUX，可控制的数据选择器？MUX 门如图所示，输入三个元素，b,d0,d1。取决于输入 b 是 0 还是 1，它选择输出 d0 或者是 d1。所以如果 b 等于 1，它就输出 d1，b 等于 0，它就输出 d0。所以这个门电路的功能可以用这个逻辑表达式表示。如果 b 等于 0，前面一项就没了，只剩下 d0，如果 b 等于 1，就只剩下 d1。这个门电路的实际功能等同于 if 控制语句，如何同态的实现他呢？
这个元件非常有用，在后面的构造尤其是自举里面会用到非常多。所以希望大家好好记住它。

第一个组成单元是旋转(Rotation)。我将会由简到难的介绍这个功能。我们先从明文开始。如果我想旋转这个多项式到p位置。M 是这个多项式，M0+M1+++，因为我们在 mod XN+1 上进行操作。我们想要获得的是系数 Mp。所以我们得旋转这个多项式使 Mp 旋转到第一个。操作非常简单，只需要对这个多项式乘上 X-P 次方，然后 Mp 就成了多项式的第一个系数，也就是 X 的 0 次方，常数项的系数。其他后面系数跟在他后面，它前面的系数将会在多项式最后系数变为负数，因为我们在 mod XN+1 上进行操作。所以这个操作很简单，只需要乘上 X-p 就行了。

现在增大一点难度对 M 的密文的 p 位置进行旋转。所以 M 是加密后的，p 已知。M将会用 RingLWE 加密，也就是橙色的密文。密文和常多项式的乘法之前讲过很简单，只需要对 A 部分和 B 部分对应相乘就行了。结果将会是 M 乘 X-P 的 RLWE 密文。也就是旋转过后的 M 的密文。所以同样也很简单，这个操作没有增加任何噪音。

但再难一点，不只是 M 加密了，位置 p 也加密了。也就是我们想要去获得的系数的位置也被加密了。我们先将 p 表示为二进制数，分别是 p0,p1,pk，假设这些二进制数以 RGSW 密文的形式提供。也就是说这 p 个元素未知，他们都是密文，2^j 是一个常量，当然知道。现在我们想要计算的是 M 乘上 X-P 来进行旋转。M 乘上 X-P 可以写成这样的二进制形式，他就等于...让我们关注其中的一项...我们直接计算...再重申一遍 M 是加密的 p 也是加密的，所以让看一下我们想得到怎样的输出。如果 p 等于 0 指数就是 0，这一项就变成了 1，输出将会变成 M。所以如果 pj 是 0，我们将得到输出的 M；如果 pj 等于 1，指数将会变成 2j，所以我们将得到输出的结果是 X 的 2j 次方。所以可能大家已经懂了，这是一个 if 条件判断，我们实现 if 的方式就是用上面提到的CMux。在这里 CMux 0 端输入 M 的密文，在对应 1 端输入 M 的密文乘上明文的...然后通过选择器 pj 的密文进行判断。输出结果是...也就是我们想得到的。

如果这一步清楚了，对整个 p 进行操作只需要构造一个 CMux 门组成的链。所以我们由 0 开始，输入密文...你将会得到一个密文 M0，他的值是...然后吧 M0 作为输入，传递到下一个 CMux 门，然后你将会得到 M1，然后一直下去最终得到 M 乘 X-P。

所以我们可以通过这种方式实现盲转，也就是对未知的多项式的未知位置进行旋转。

这个可能是最难的构造单元，后面的会简单很多。下一个是采样提取器(sample extraction)，他输入一个 RLWE 密文，加密的是多项式 Mx，他的构造方式前面已经看过了，然后你想要把多项式 M 的系数提取出来。这意味着你不知道 M，但你想得到他的一个系数，作为 LWE 密文。这里以 M0 做例子。这个很简单，只需要以特定顺序重新排列 M，然后复制输出的 LWE 密钥为对应 RLWE 密钥的系数向量。这个操作不会增大噪音，只需要重新排列 M 的系数就可以了，当然不只是 M0 可以被提取出来，任何一个系数都可以被提取出来，只需要以合适的方式重新排列输出的系数。

最后一个也很重要，是密钥更换。假设你有一个输入的 m 的密文，其对应的密钥是 s，你想要输出一个同样是 m 的密文，其密钥是 s'，这个操作需要一个密钥叫做密钥更换密钥，是一个公钥，跟后面会提到的自举密钥非常相似。不只是可以交换密钥，也可以更换参数，如果需要更换参数，也可以通过这个操作。密钥更换不只可以在 LWE 和 RLWE 密文实现，也可以从 LWE 到 RLWE。用处有点像你想的采样提取。采样提取使一个 RLWE 的参数到 LWE，密钥更换可以输入一个 LWE 密文，然后将其明文放到 RLWE 多项式的一个参数里。再广一点可以把很多 LWE 明文放到一个 RLWE 里面。有点类似打包。

密钥更换同时可以同态计算一些常规的函数，可以是公开的或者是非公开的，我们把它叫做功能型密钥更换(functionality key switching)。但很遗憾这个组成元件会增加噪音。虽然输出会有更高的噪音，但很多时候它的功能非常重要。

这是最后一个组成单元，最后用一张幻灯片总结。我们定义了外积和 CMux，使 RLWE 和 RGSW 得以交互，输出一个 RLWE 密文。我们可以进行旋转操作，所以我们可以旋转 RLWE 密文。我们可以进行采样提取，可以提取 RLWE 密文的一个参数到 LWE；如果需要，我们可以用密钥更换回到 RLWE。

# bootstrapping

接下来是最具有技术性的最后一个部分。自举的作用是降低噪音。TFHE 里我们可以对 LWE 密文进行自举。自举需要去执行解密电路，也就是打开蓝盒子。我们将同态的打开蓝色盒子来降低噪音，所以明文将会一直保持加密状态。解密的步骤分为两步，第一步就是前面提到的计算 b-as 然后得到 delta m+e。第二步对它取整获得明文 m。

自举想要得到一个噪音更小的同样是 LWE 加密的密文。让我们首先先从第二步开始，倒过来看。所以我想对 delta m+e 取整，这是我的目标。同样从易到难，假设明文 m，之前说过可以有 p 中不同的取值，这些值都被加密进了一个多项式的系数里，这里以一个向量表示。如果我想要提取出消息 m，假设被加密在中间，我要做的就是对这个多项式进行旋转，也就是乘上 X-m，m 就会被放到第一个系数，我们就得到了 m。

现在来看我们的目标，我们不知道 m，m 是我们要得到的，我们现在要得到 delta m+e。现在有 0 到 q-1 q 个可能的值，被加密到这个多项式里，然后我们想提取出 delta m+e，做法跟上面一样，只需要乘上...就能把 delta m+e 带到第一个位置。我们通过旋转操作将想要的系数放到第一个位置。

现在我们得到了 delta m+e，想要得到 m。我们需要对旋转操作的向量做一些变化。我们不再只给出 0 到 p-1，而是对它添加一些冗余，我们需要重复里面的每个明文元素。也就是不再是 0 到 q-1，而是重复 delta 个 0，delta个 1 一直到 delta 个 p-1，因为我们的消息是从 0 到 p-1。这里总共有 p 个元素，而他们的排列方式正好是一个 Torus，这个向量里面的 q 个值正好是 Torus 里面每个离散的刻度。delta 正好是红线区域的长度，所以每个重复的元素都代表着被红线划分的一个区域。这里我将 0 一分为二，为了能更好的体现这个转盘的思想。如果我们从 0 开始，逆时针不断增加，最后又回到另一半的 0。如果这个消息没有任何噪音，消息 0 就会正好落在起点，如果有一定不超过限度的噪音，消息加噪音就会落在 0 的红框范围内，但消息的值还将会是 0。

所以我们对这个向量，这个多项式进行旋转，如果它不包含噪音，m 将会作为第一个系数正好落在起点，如果有噪音，它将会偏移一些，但始终还是在全都是 m 值的红框里。所以借助这个向量，我们完成了对 delta m+e 的取整。我们输入了 delta m+e，并且通过旋转我们得到了第一个系数为 m 的密文的多项式，也就成功提取出了 m。

我管这个含有不同 m 的可能取值的向量 V，所以我们只需要计算 V 乘上...当然这是第二步，我们要在第一部得到 delta m+e。但一个问题是在这里我们用的向量长度是 q，但实际运用时 q 是一个相当大的值，通常是...这里的一个向量实际上表达的是一个多项式，用这么大的多项式非常不可行。实际使用是我们会用更小的参数比如 2^10 次方。同时我们希望能够编码更小的值，所以实际操作时我们只会保留密文的高位，也就是明文信息，舍去低位噪音，也就是保留消息的同时将 q 变得更小。这也会让噪音增长一些。(modular switching)

现在我们知道了怎样进行取整，现在回到第一步，如何计算 delta m+e。还记得 delta m+e 等于 b-as，展开之后就是...我们希望同态的计算 delta m+e，a 和 b 都是已知的因为他们都是密文的一部分。s 作为密钥不知道。我们将会以自举密钥的形式提供他们的 RGSW 密文，所以 s 的每一个 bit 都被加密为 RGSW 密文。所以里面的明文是 0 和 1。自举过程首先设置和上面第二步一样的冗余向量 V，然后计算 b 位置的旋转，所以我们获得了 b，然后我们一个一个的加上 as，因为 s 是 0 或者 1 的密文，进行这个操作意味着选择输出指数是 0 或者是 1。我们之前也见过类似的操作，在盲转里面。所以我们跟之前一样的操作，因为 s 是 0 或者 1 的密文，根据他的值我们将选择输出 V0。最终逻辑上我们将输出 V0...于是我们得到了第二部分，然后迭代进行同样的操作直到获得 Vn-1...只需要将多个 CMux 门串联在一起就可以了。最终的结果就是我们期望的 VX...所以第一步我们也完成了。

两步连起来总结一下，自举输入一个 m 的 LWE 密文，然后计算这样的一个和盲转，也就是对输入向量的 delta m+e 位置进行旋转，目的是把复数个的 m 的密文旋转到第一个位置。但是最终我们希望获得的是一个 LWE 密文而不是一个 RingLWE 密文。所以我们怎样把 RingLWE 密文的一个系数提取出来，只需要进行一次采样提取，所以我们采样提取了多项式的第一个参数，也就是 m 的密文。经过这样的步骤我们获得了 m 的密文，但是他的噪音更小了。所以自举的目的达成了。我们可以看到自举前后的密钥是不一样的。输入的密文对应的密钥是 s，而输出的是 s'。如果我们想要把密钥变回 s 也只需要一次密钥变换就可以了。

这就是 bootstrap 在 TFHE 实现的大致思想。但实际上除了单纯降低噪音，他还可以执行更多功能。自举是可编程的，可以在降低噪音的同时计算一个特定函数。方法是将自举最开始使用的向量 V 的每个元素变为想要执行的函数。之前是 delta 个的 0，1...我们将其变换为 f(0)，f(1)...在实际操作中，我们在这个向量 V 里对所有可能的输入做了一个查找表的操作(look up table evaluation)，然后就像之前一样将这个向量输入进自举，然后盲转就会将 f(m) 放在开头，然后我们就能够得到 f(m)。所以我们实际上对 m 进行了一次 f 的变换。同时降低了噪音。

最后一张幻灯片总结了所有东西，我们有三种密文，LWE 可以进行自举，自举可以降低噪音，这里用虚线箭头表示。TFHE 还有一种自举叫做电路自举，也是用上面说的自举方式实现的，只不过稍微有一点复杂。能使我们从 LWE 到 RLWE 的同时降低噪音。如果我们把所有的组成单元都加回来，我们可以在各种密文之间自由变换。通过这些组成单元我们可以实现很多很多操作，构造所有想构造的东西。
