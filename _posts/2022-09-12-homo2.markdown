---
layout:          post
title:           "Fully H0M0morphic Encryption II"
subtitle:        "十分难顶，甚至有九分。"
date:            2022-09-12 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

其实是一个 [TFHE](https://eprint.iacr.org/2018/421.pdf) 学习小记。非常感谢作者 Ilaria Chillotti 的讲解和 [FHE_org](https://www.youtube.com/watch?v=npoHSR6-oRw) 让我这种笨比也有机会领会这么高级的 FHE 方案。

组织了五个章节。首先咱简单讲讲关于全同态的一些常识，比如什么是全同态加密。然后深入讲解一下 TFHE。主要介绍 TFHE 所用到的密文。然后讲解一下使用这几种密文的构成单元(building blocks)和使用这些构成单元所能进行的混合操作。然后是如何进行自举(bootstrapping)。最后讲讲相关的实现和应用。

# FHE

## 什么是 FHE

FHE 所实现的功能概括来讲就是将密文的操作权和所有权分开。

比如这张图里面密文是 $x$，用一个带锁的蓝色盒子表示对其加密。所以一个带锁的蓝色盒子和里面的明文就表示了其密文。FHE 允许咱对密文执行对应操作，最简单的就是加操作，对应逻辑电路里的 XOR。比如有 $x$ 的密文和 $y$ 的密文，我们对密文进行加操作，结果将是一个新的密文对应明文 $x+y$。乘法也是一样对应 AND，我们对 $x$ 的密文和 $y$ 的密文进行乘操作将会得到 $x\times y$ 的密文。需要注意的一点是对密文空间的操作标成了黄色，而对明文空间的操作标成了红色。原因是对密文空间的操作将会比对明文空间的加和乘更为复杂。后面将会看到在 TFHE 中是怎样实现的。

FHE 意味着全同态，我们希望能够对任意由加法和乘法所组成的函数能够没有任何限制的执行。同时我们希望对明文也没有任何限制，我们希望可以加密bit,integer,real messages。我们也希望能够实现secret key,public key~~对称非对称~~两种加密模式。但在本文中我将会关注对称模式，因为不同于传统的密码学体系在全同态下对称和非对称加密体系实际上是等价的。一个非对称的加密体系可以由对称体系很容易得到(~~通过密钥派生~~)。

FHE 在云服务场景下非常有价值，我们的隐私将会得到充分的保护。比如有一个云服务提供商，它提供了非常有用的数据计算服务，但现实生活中的很多敏感数据不想让这些隐私被云服务商以及监听信道的第三者得到，就需要借助密码学将其加密上传给云。如果使用全同态加密，云服务提供商在无法获知数据内容的情况下也可以对加密的数据进行计算服务，数据的整个生命周期内都是加密的状态，只有数据拥有者才能够得知数据信息，并且不存在数据泄漏，因为就算有黑客攻破了云服务器，数据也同样是加密的。服务器端的限制也将会更小，服务器可以设在世界各地，即使每个地区的隐私政策都是不同的。

假设你是个计算机视觉的苦逼研究生(~~假设不需要这个假设~~)，买不起非常高级的设备，必须要借助云炼丹服务来完成自己的科研，这时候你肯定不希望自己的数据集，自己炼的模型被云服务提供商或是其他第三方剽窃，这时候就可以借助全同态，将加密的数据集和代码上传至云计算服务器，经过神经网络在加密的数据上进行计算返回给你加密的模型，然后再用你自己的密钥进行解密。云在不知道你上传的数据的情况下帮你炼了丹。

FHE可能会在未来改变英特网的工作模式，$HTTPS\to HTTPZ$，默认使用全同态加密协议与服务器建立连接，服务器将不会得知你发送的任何敏感数据比如电话号码，位置，ip，密码，且仍能够为你提供服务(~~现阶段只是一种设想~~)。

但是，~~古尔丹~~，代价是什么呢？全同态加密过程中的代价主要是一些咱称之为噪音的随机数。之前一张图里展示了对密文进行加操作和乘操作的过程，实际上当我们对明文进行一次加密之后就已经加入了一定的噪音。噪音实际上就是确保密码学功能安全的随机数，我们需要密码学功能是概率性的，所以我们至少在现在没办法取消他们。这里用密文右上方的温度计表示噪音程度。最开始噪音程度很低，但当我们进行同态的加或者乘操作之后噪音会变大。特别是进行乘操作之后噪音会比加操作更大。这实际上是一个痛点，因为如果噪音大小超过临界值，也就是温度计上的红线，将有概率无法正确解密。这一点是让全同态在 2009 年之前无法实现的原因之一。

## bootstrapping[[Gen09](http://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf)]

2009年，Gentry 用了一个很巧妙的方法 ，我把它翻译成自举(bootstrapping)。自举功能就是在噪音即将突破临界值时处理噪音。先简单介绍下，后面会详细讲讲 TFHE 的自举。

自举的思想是：当你有了一个密文 $x$，它的噪音即将突破临界值，这意味着我们将无法对其进行任何同态操作。所以只能停止，或者想办法降低它的噪音。最简单的降低噪音的方式就是对它解密，解密意味着把明文从盒子里拿出来，那么噪音也将不复存在。但解密需要密钥，同时密钥又不能交给云或者其他第三方来刷新噪音，不然我们对它加密还有什么意义。

Gentry 的方法是直接保留这个噪音很大的密文，就是这个蓝盒子，然后再把它放在一个绿盒子里。这个绿盒子是再一次的全同态加密。把蓝盒子放在绿盒子里面也不会改变任何蓝盒子的噪音。但由于这是一次全同态加密，绿盒子也会如温度计所示的带有一定的噪音，现在我们要做的是打开绿盒子里面的蓝盒子，也就是对蓝盒子解密。打开蓝盒子需要蓝色的钥匙。所以我们就给他蓝色的钥匙，但是得把它装在绿盒子里。我们将这个密文叫做自举密钥(bootstrapping key)，这是一个公开密钥，并且不会暴露我们手上的密钥信息。现在我们有一个装在绿盒子里的蓝盒子和一个装载绿盒子里的蓝钥匙，我们可以同态解密打开蓝盒子，结果将会得到一个绿盒子对明文的加密。如果看到这个绿色的温度计，它确实比之前会上升一点，但距离临界值还有一定的空间，这允许我们进行进一步的全同态操作。在实际操作中我们可以在进行同态操作之后尽快的自举，这样就会有一定的空间可以在临界值之前进行一些的操作，然后又回到自举开始之前。所以通过链式的不断自举我们可以构造任何电路，不会再有操作次数的限制。

## 两条支线

尽管自举是一个非常有用的技术，但它是全同态加密过程中开销最大的操作。所以又有不同的声音，我们在构造全同态加密的时候真的需要一直自举吗？答案是具体问题具体分析。如果你想同态(~~我翻成~~)计算(evaluate)的电路很小，并且你对他的构造很清楚，这意味着你知道要对它进行多少次同态操作，那我们对他采取(~~我翻成~~)精准的方法(leveled approach)，如果电路很大，并且你作为生成密钥的人不知道它的构造，那么我们就采用自举方法(bootstrapped approch)。

精准方法指尽可能避免自举，在进行同态计算之前必须知道要进行多少次操作，然后得固定参数以适应你要执行的操作数，使噪音控制在可接受的范围内。当然电路越大，参数设置的越大，密码学的操作将会变得更慢，所以越多的操作要执行，开销也会越大。

如果你想要更加灵活的或者是电路未知，这时候可以用自举方法，这样对操作次数就没有限制，需要不断对电路进行自举。

## 时间线

所以我们是怎么使用全同态的，是用一种方法还是两种都用？我将会用一条高度概括的时间线解释，只会列出一些代表性的文章。第一次提出实在 1978 年，然而这个问题非常难，经过 30 年也没有找到一个解决方法，这段时间诞生的方案被称为部分同态方案，可能是只有加或者乘的同态，也可能是能同时进行加和乘运算，但存在限制。直到 2009 年 Gentry 提出了自举和可以用理想格构造全同态之后学者们提出了很多很棒的成果。2010 年提出了 DGHV，是一个基于格上的 Approximate-GCD 问题在整数上进行操作的方案。虽然没有被用到现在，但是是一个很直观的方案。非常适合解释什么是全同态。然后在 2011 年，第一个基于 LWE 困难问题的 FHE 方案被提出，叫做 BGV。LWE 是一个格上的平均情况计算困难问题，拥有很多传统困难问题所不具备的优越性。之前也讲过比如抗量子计算攻击，存在最环情况到平均情况的归约，能够构建很多高级密码学功能比如安全的多线性映射等等。之后在 2012 年，另外一个基于也是格问题的 NTRU 的分支被提出，虽然在今天可能面临一些重大的安全性问题，但也是很好的方案。2013 年我们有了另一个基于 LWE 的方案叫做 GSW 方案。现在所更为充分研究的就是基于 LWE 问题的分支，也就是 BGV 和 GSW 分支。BGV 在 2012 年有一个变体叫 BFV，GSW 在 2014 年的变体叫 FHEW，提出了一种非常快的基于 GSW 的自举方法。所以延续到至今的有主要有两个分支，一个是 BGV 分支，更加偏向于精确的方案，避免使用开销大的自举，以及 GSW 分支使用更快的自举，允许我们尽情使用自举。BGV 分支后来有了 CKKS，是一个使用至今的著名方案，同时在 GSW 分支有了 TFHE，也就是这次要讲的。TFHW 最开始是对 FHEW 的提升，之后发展出了很多功能。如果看过这两条支线的构造就会发现实际上这两条直线之间的差别比想象的要小。比如 [BGGJ19] 提出了一种通用框架使得 TFHE 和 HEAAN[CKKS17]可以同时工作，或者说可以很简单的变换到另一种方案。

# TFHE

现在让我们抛开一些技术细节简单的看一看 TFHE 方案。如果对代数和格计算问题不是那么熟悉也没关系，这里我会讲的尽可能简单，讲完整个方案构造之后才会涉及到技术细节。

## TFHE 密文

### LWE

首先从 TFHE 的密文开始。TFHE 里一共有三种密文，第一种叫 LWE。LWE 就是格上的一个困难问题，我们用这个问题来来加密明文。LWE 密文用来加密一个消息，可以是一个比特，一个模整数，一个特定区间内的实数。密钥是一个由短向量，每个元素都是一个比特，可以看成是随机比特。是否用比特不是强制的，也可以用其他类型的密钥，比如 LWE 问题常用的 ternary keys，i.e.，$\qty{-1,0,1}$,gaussian keys。这里我将重点关注比特密钥。

密文由 $n+1$ 个元素组成，前 $n$ 个元素是向量 $a$，最后一个元素是 $b$。$a\_i$ 均匀随机的在 $\mathbb{Z}\_q$ 中选取，也就是模 $q$ 整数。最后一个元素 $b$ 由所有 $a$ 元素和密钥的乘积组成，然后再加上特定的噪音 $e$，和密文和标量 $\Delta$ 的乘积。这里的噪音 $e$ 就是一个服从特定分布，一般是离散高斯分布的噪音。所以均匀随机的 $a$，乘上密钥的随机元素，然后加上噪音，和消息，然后得到了 $b$

解密时我们知道密钥，直接计算 $b-\mathbf{a}\mathbf{s}$ 这将会得到 $\Delta m+e$，然后我们直接进行取整，或者叫舍入，就得到了 $m$。

取整是一个非常简单的操作，通过这张图就能很好理解。这张图只是一个可视化的直观的很简单的例子，并不是真正使用时的参数。当我们对 $q$ 取模时，就像用了一个离散的转盘(Torus)一样。转盘就是这个圆圈，0 在底部，逆时针依次增大，1,2,3 一直到61,62,63，$q=64$，所以当我们数到 64 就又回到了0。这就是模 $q$ 的思想。如果我们设定 $q$ 等于 64，那么我们可以使用最多 6 bit 的密文。然后选一个 p，p 是我们想要加密的明文的数量，在这个简单例子里是 4 个元素。这意味着我们有两个 bit 的明文信息。$\Delta$ 则是 $q$ 和 p 的比。为了可视化的表示，p 是我们可以加密的明文的数量，只有这四个元素里面一个消息能够加密到密文里面。也就是我们有四种选择。因为有四种选择，所以有两个 bit 可以表示他们。我们将把它加密到密文的最高位 bit。$\Delta$ 在这里表示了这个转盘上的一个消息和第二个之间的距离。所以消息将会被分散开 $\Delta$ 距离。之前说过我们要计算 $\Delta m+e$，噪音的大小必须被限制。它被限制为 $\Delta/2$。在加密过程中我们把噪音放在密文的最低位 bit。在这个转盘里红色的线表示对特定密文添加的噪音的范围，不能超过这条红色的线。

我们给出一个非常简单的例子。比如我们想对 3 加密，3 将被编码为 $\Delta m$ 在这个例子里等于 48，在转盘的这个地方。在密文的最高位编码了二进制的 3，然后我们加上一些噪音等于 5


# 技术细节





TFHE实际上提供了一个更高效的 FHE 的砖块：一个自举的 NAND 门。NAND门具有 Functional Completeness，这意味着可以只用 NAND 门构造任何电路。同时由于全同态加密会在每一步操作之后造成噪音的累积，自举的 NAND 门可以在每一次执行 NAND 时刷新噪音。所以这确实是一个实用的砖块，能够用他构造任何全同态方案。

这篇文章实际介绍了两种 TFHE，分别对应上文两条支线的自举方案[CGGI16]和精确方案[CGGI17]。在之后介绍自举方法时会有所区分。

第一个问题是为什么叫TFHE。FHE 代表全同态加密，T则代表 Torus。方案定义了一种代数结构叫 Torus。我们用到是实数 Torus。

$$\mathbb{T}=\mathbb{R}/\mathbb{Z}=\mathbb{R}\bmod 1$$

所有模 1 实数。如果定义了加法和整数环上的数乘，$(\mathbb{T},+,\cdot)$，Torus 就是一个很好的 $\mathbb{Z}$-模。模结构和线性空间很类似，在加法上是一个交换群，这说明如果我们拿两个 Torus 元素，我们可以把它加在一起，加法可以被定义；我们也进行数乘运算，如同线性空间里的标量乘一样。如果拿一个蓝色的 Torus 元素和一个红色的整数环的元素，对他们俩进行数乘结果是一个 Torus 元素。数乘也是可以被定义的。但它并没有环的结构，这意味着乘运算没有被很好的定义。

有了 $\mathbb{Z}$-模的属性之后，可以非常简单的将其拓展到多项式。这里用 $\mathbb{T}\_N\bqty{X}$ 表示系数在 Torus 里的多项式，也就是系数为模 1 实数的多项式，模上多项式 $x^N+1$。然后 $(\mathbb{T}\_N\bqty{X},+,\cdot)$ 是 $\mathfrak{R}$ 上的模，$\mathfrak{R}$ 是 Ring-LWE 里用到的整数多项式模 $X^N+1$。同样我们可以在 Torus 多项式上进行加法和整数多项式的数乘，但两个 Torus 多项式之间的乘法没有定义。

上面的对这个代数结构的介绍，如果对代数不太熟悉也没有关系，


个人感觉咱可以这样利用一个高性能(~~逼格~~)的全同态方案，难度从易到难排序：

1. 拿来主义。直接将这个方案用在相关领域。毕竟是全同态，可以运用在几乎每一种场景。
2. extanded TFHE。在原方案或者其他方案的基础上类似方案的功能，实现一些原方案所不具有的功能。比如 [MK-TFHE](https://scholar.google.com/citations?view_op=view_citation&hl=en&user=w_OlJw8AAAAJ&citation_for_view=w_OlJw8AAAAJ:Y0pCki6q_DkC)
3. 全同态领域的创新。比如 TFHE 比起 FHEW 就提出了使用一种代数结构 TORUS 进行操作。