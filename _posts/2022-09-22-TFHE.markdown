---
layout:          post
title:           "TFHE"
subtitle:        "ドーナツ食べたくなった(*´_ゝ｀)"
date:            2022-09-22 00:10:00
author:          "kara"
header-img:      "img/post-bg-unix-linux.jpg"
tags:
    - cryptography
    - lattice
    - algebra
    - FHE
    - cipher

---

其实是一个 [TFHE](https://eprint.iacr.org/2018/421.pdf) 随便记记。非常感谢作者 Ilaria Chillotti 的讲解和 [FHE_org](https://www.youtube.com/watch?v=npoHSR6-oRw) 让我这种笨比也有机会领会这么高级的 FHE 方案。

[TFHE Deep Dive from ZAMA](https://www.zama.ai/post/tfhe-deep-dive-part-1)

# Algbra

TFHE 提供了一个更高效的 FHE 的砖块：一个自举的 NAND 门(~~主要是自举比较高效~~)。其实就是LWE密文？NAND 门具有 Functional Completeness，这意味着可以只用 NAND 门构造任何电路。同时在每一次执行 NAND 时刷新噪音。并且可以同态执行任何(?)函数。

FHE 代表全同态加密，T则代表 Torus。一种代数结构。我们用到是实数 Torus。~~有没有可能能用环~~

$$\mathbb{T}=\mathbb{R}/\mathbb{Z}=\mathbb{R}\bmod 1$$

所有模 1 实数。如果定义实数加法和整数环上的数乘，$(\mathbb{T},+,\times)$，Torus 是一个 $\mathbb{Z}$-模(~~任何阿贝尔群都是~~)。模结构和线性空间很类似，在加法上是一个交换群，数乘运算也如同线性空间里的标量乘一样。但它并没有环的结构，原文是实数乘法和模运算不相容。对于两个不同等价类里元素，实数乘法：

$$\exists t_1,t_2\in \bar{t_1},\bar{t_2}\colon t_1 \cdot t_2\bmod 1\neq(t_1\bmod 1)\cdot(t_2\bmod 1)\bmod 1$$

有了 $\mathbb{Z}$-模的属性之后，可以将其拓展到多项式。$\mathbb{T}\_N\bqty{X}$ 表示系数在 $\mathbb{T}$ 里的多项式，模上分圆(~~主要是整系数不可约~~)多项式 $x^N+1$。然后 $(\mathbb{T}\_N\bqty{X},+,\times)$ 是 $\mathfrak{R}=\mathbb{Z}\bqty{X}/(X^N+1)$ 上的模，$\mathbb{T}\_N\bqty{X}\bmod(X^N+1)$同样可以在 Torus 多项式上进行加法和整数多项式的数乘，但两个 Torus 多项式之间的乘法没有定义。

这里用 $\mathcal{R}$ 表示多项式环 $\mathbb{Z}\bqty{X}/(X^N+1)$，$\mathcal{R}\_q$同理。高斯分布 $\chi\_{\mu,\sigma}$。如果 $\mu=0$ 记作 $\chi\_\sigma$。

# cipherS

用三种密文的原因主要是充分利用每种密文的属性。[但好像只用 LWE 就可以构造一个全同态](./2022-09-01-homo.markdown)。GSW 密文 20 年的新论文和 16 年的好像不一样？

## GLWE

yysy，LWE 问题在 FHE 构造里有够被简化，应该有相关的安全性研究？LWE 和 RLWE 加密方式本质上是一样的，LWE 的明文可以被加密成多项式的一个系数。所以密钥直接记作(~~因为多项式所以直接用大写字母~~)：

$$\vec{S}=\pqty{S_0,\dots,S_{k-1}}\in\mathcal{R}^k$$

这样 $A$ 的每一个元素和 $B,M,E$ 都属于 $\mathcal{R\_q}$ 了。多项式系数可以是均匀随机的：二进制分布，三元分布，高斯分布或者均匀分布。对于每种类型的密钥都可以实现特定安全等级的参数。例子里是二进制。

$p,q$ 一般选为 2 的幂，如果不这样在编码消息，i.e.，$\Delta M$ 的时候就需要 rounding。$q$ 一般叫做密文模数，$p$ 叫做明文模数。$\Delta$ 放缩因子？(~~scaling factor~~)密文直接：

$\pqty{A\_0,\dots,A\_{k-1},B}\in GLWE_{\vec{S}, \sigma}(\Delta M) \subseteq \mathcal{R}_{q}^{k+1}$

一般把 $\pqty{A\_0,\dots,A\_{k-1}}$ 叫做 mask，B 叫做 body。每次加密都会采样随机的随机数(mask 和 error)。所以上面式子用的 $\in$。解密就典中典之减一减得到 $\Delta M+E$，然后再 rounding。

模 $X^N+1$ 利用 $X^N\equiv -1$。

Trival GLWE ciphertexts：

$$(0, \dots, 0, \Delta M) \in \mathcal{R}_{q}^{k+1}$$

用来当成公开参数，公钥就 $M$ 也全是 0 再线性组合。

## LWE and RLWE

$k=n\in\mathbb{Z}$(~~为什么要区分 k 跟 n~~) 且 $N=1$ 就得到了 LWE。此时 $\mathcal{R}\_q$ (resp. $\mathcal{R}$) 就是 $\mathbb{Z}\_q$ (resp. $\mathbb{Z}$)。

![](/img/TFHE/LWE.png)

$k=1$ 且 $N$ 是 2 的幂就得到了RLWE。(~~为什么要是 2 的幂~~)

![](/img/TFHE/RLWE.png)

## GLev

leveled 方案里用的很多。实际上就是用冗余的和精心设计过 $\Delta$ 的 GLWE 加密单个消息 $M$。密文密钥都跟 GLWE 一样。虽然一直在用，但正式命名貌似非常的晚([CLOT21](https://eprint.iacr.org/2021/729.pdf))。$\Delta$ 底为 $\beta$，通常为 2 的幂和层数 $\ell$

$$\left(GLWE_{\vec{S}, \sigma}\left(\frac{q}{\beta^{1}} M\right) \times \ldots \times G L W E_{\vec{S}, \sigma}\left(\frac{q}{\beta^{\ell}} M\right)\right)=G L e v_{\vec{S}, \sigma}^{\beta, \ell}(M) \subseteq \mathcal{R}_{q}^{\ell \cdot(k+1)}$$

$\times$，笛卡儿积。$\beta,q$ 如果不是 2 的幂，编码的时候需要 rounding。解密就对对应 $\Delta$ 的 GLWE 解密 1 次就行。同样的也有 Lev 和 RLev。

![](/img/TFHE/GLev.png)

## GGSW

说白了就是冗余~~复读~~。

* GLWE 密文是 $\mathcal{R}\_q$ 元素组成的向量(1 维矩阵)。
* GLev 密文是 GLWE 密文组成的向量。($\mathcal{R}\_q$ 元素组成的 2 维矩阵)
* GGSW 密文是 GLev 密文组成的向量。($\mathcal{R}\_q$ 元素组成的 2 维矩阵，或 GLWE 密文组成的 2 维矩阵)

$$\left(GLev_{\vec{S}, \sigma}^{\beta, \ell}\left(-S_{0} M\right) \times \ldots \times GLev_{\vec{S}, \sigma}^{\beta, \ell}\left(-S_{k-1} M\right) \times GLev_{\vec{S}, \sigma}^{\beta, \ell}(M)\right)=GGSW_{\vec{S}, \sigma}^{\beta, \ell}(M) \subseteq \mathcal{R}_{q}^{(k+1) \times \ell(k+1)}$$

注意每个 GLev 密文中密钥的 $S\_i$ 项和 $M$ 的乘积。密钥 $\vec{S}$ 跟 GLWE 和 GLev 密文相同。解密时对最后一个 GLev 密文解密就够了(~~毕竟 $\Delta$ 最简单。i.e.，对里面任意一个 GLWE 密文解密~~)。GSW 跟 RGSW 与上文同样操作。

![](/img/TFHE/GGSW.png)

# Encodings and linear leveled operations

加法数乘就对应元素分别计算，没什么好讲的。数乘的噪音增加跟常数多项式 $\Lambda$ 的系数成比例。数乘大数需要操作，下文会讲。

## Encoding integers in the MSB

TFHE 错误编码在 LSB，消息编码在 MSB。一些方案跟他一样，比如 [B](https://eprint.iacr.org/2012/078.pdf)/[FV](https://eprint.iacr.org/2012/144.pdf) 和 [HEAAN/CKKS](https://eprint.iacr.org/2016/421.pdf)。一些反过来，比如 [BGV](https://eprint.iacr.org/2011/277.pdf)。

GLWE 能支持更多不同的编码方式。

![](/img/TFHE/encd1.png)

这种编码可以实现模 $p$ 的(leveled operation)分级(~~佛了，原来中文翻译是分级。R18是吧~~)操作(加法和数乘)。比如两个 GLWE 密文用相同的 $\Delta$ 编码在 MSB，加一加结果就是两个明文的模加法，$\Delta$ 不变。当然噪音也加一加，并且还有可能会进位。(~~进位是不是就表示 g 了~~)例子：$q=2^{32},p=2^7,\Delta=2^{25},m\in\mathbb{Z}\_p$。

## Encoding integers in the MSB with padding bits

编码通常会被我们想实现的全同态操作影响。padding 就是前面空一些给分级操作(加法和数乘)提供空间。例子：$q=2^{32},p=2^7,\Delta=2^{25},p'=2^5,m\in\mathbb{Z}\_p'$。也就是有 2 bit padding。

![](/img/TFHE/encd2.png)

这种编码可以实现精确的分级操作。加结果就直接是加。

## Encoding of binaries in GB mode.

一个带 padding 的例子是门自举(gate bootstrapping)里面的。门自举对加密 bits 的 LWE 密文计算二元门(binary gate)。实现可以看 [TFHE lib](https://tfhe.github.io/tfhe/) 和 [concrete](https://github.com/zama-ai/concrete/)。

编码消息是 bits，$\Delta=q/4$，所以有 1 bit 的 padding。因为自举过程中间过程要实现精确的线性组合来得到最终结果。(~~估计就是那一长串的 CMux 门~~)

## Encoding of reals

固定区间内的实数，消息和错误彼此都难以分离...$m$ 占据了整个 $\mathbb{Z}\_q$(~~怎么用 $\mathbb{Z}\_q$ 表示实数的，计组里的表示法吗？~~)，LSB 被 $e$ 扰乱，近似(approximates)了信息。实践里，$m+e$ 和 $m\colon m\approx m+e$ 接近。但无法分辨出 $m$ 因为没有 $\Delta$ 可以区分开消息和错误(~~yysy，还是得看实数编码的方式8~~)。

![](/img/TFHE/encd3.png)

这种编码在计算近似达到特定精度的分级操作(approximate leveled operations)(加法和数乘)时很实用。

解密第二阶段 rounding 变化，在 LSB 加一个新的随机错误。可以看[这篇文章](https://eprint.iacr.org/2020/1533.pdf)。

这些编码只是一部分，还有很多。(~~感觉挺自由的~~)

## Torus visualization

一维环面 $\mathbb{R}/\mathbb{Z}$ 说白了一个光滑流形，一条线，一个圆。(~~官图给的二维甜甜圈有够欺诈，想了老半天~~)(~~不知道多维环面可不可行，感觉没必要，也就用到 rounding~~)(~~说不定 ring 的 rounding 能用？~~)。

![](/img/TFHE/torus.png)

注意一下负数等价类在 torus 上的表现。

# Key switching and leveled multiplications

## Homomorphic multiplication by a large constant

![](/img/TFHE/g.png)

系数太大的数乘 $e$ 太大可能直接 g，所以才需要分解(decomposition)。跟 GSW 密文乘法类似。把大的常多项式分解为小的基 $\beta$：

$$\gamma=\gamma_{1} \frac{q}{\beta^{1}}+\gamma_{2} \frac{q}{\beta^{2}}+\ldots+\gamma_{\ell} \frac{q}{\beta^{\ell}}$$

分解出来的元素 $\gamma_{1},\dots,\gamma_{\ell}\in\mathbb{Z}\_\beta$ ，就小了。写成 $\mathsf{Decomp}^{\beta,\ell}(\gamma)=(\gamma_{1},\dots,\gamma_{\ell})$。$q,\beta$ 一般取成 2 的幂，不然需要 rounding。

![](/img/TFHE/decp.png)

分解出来的元素都很小，现在和密文相乘对噪音影响很小。但为了得到与 $\gamma\cdot M$ 相同的结果，我们需要能对逆向分解过程，重组(recompose) $\gamma$。

因此部将分解出来的元素与 $M$ 的 GLWE 密文相乘，而是与 $M$ 的 GLev 密文相乘。根据定义，加密了 $M$ 乘上 $\beta$ 的不同指数作为系数：

$$
\bar{C}=\left(C_{1}, \dots, C_{\ell}\right) \in\left(GLWE_{\vec{S}, \sigma}\left(\frac{q}{\beta^{1}} M\right) \times \dots \times GLWE_{\vec{S}, \sigma}\left(\frac{q}{\beta^{\ell}} M\right)\right)=GLev_{\vec{S},\sigma}^{\beta,\ell}(M) \subseteq \mathcal{R}_{q}^{\ell \cdot(k+1)}
$$

实践中，用一个类似内积的操作，所以将每一个分解的元素和 GLev 密文的对应元素对应相乘然后把他们加在一起。(~~所以论文里这一大堆式子是这么来的~~)

$$\left\langle \mathsf{Decomp}^{\beta,\ell}(\gamma), \overline{C} \right\rangle = \sum_{j=1}^\ell \gamma_j \cdot C_j \in GLWE_{\vec{S}, \sigma'}\left(\gamma \cdot M\right) \subseteq \mathcal{R}_q^{k+1}$$

$\sigma'$ 是噪音新方差。

![](/img/TFHE/consMult.png)

输出的 GLWE 密文不再有 $\Delta$(~~因为系数加一加加乱了？~~)，新的消息可能占据整个空间 $\mathbb{Z}\_q$。实践里并不直接用这个操作，而是作为更复杂操作的一个构成单元。比如密钥交换和密文之间的同态乘。

## Approximate decomposition

上面的是全精度分解($\beta^\ell=q$)，有时没必要。可以近似分解到指定精度($\beta^\ell<q$)。分解之前对 LSB 进行 rounding。

![](/img/TFHE/apprCsmt.png)

分解参数选的恰当就不会影响到计算正确性。LSB 肯定是噪音。一些同态操作里非常方便。

## Multiplication by a large polynomial

同样的方法乘上一个大的多项式。分解多项式再与 GLev 密文内积。假设多项式是 $\Lambda = \sum\_{i=0}^{N-1} \Lambda\_i \cdot X^i$，分解就是

$$\mathsf{Decomp}^{\beta,\ell}(\Lambda) = (\Lambda^{(1)}, \ldots, \Lambda^{(\ell)})$$

$\Lambda^{(j)} = \sum\_{i=0}^{N-1} \Lambda\_{i,j} \cdot X^i$，其中 $\Lambda_{i,j} \in \mathbb{Z}_\beta$ 使得：

$$\Lambda = \Lambda^{(1)} \frac{q}{\beta^1} + \ldots + \Lambda^{(\ell)} \frac{q}{\beta^\ell}.$$

如果分解是近似的，等式也是近似的。这个操作是密钥交换和同态乘法的主要构成单元。

## Toy example

老参数：$q=64,p=4,\Delta = q/p = 16,N=4,k = 2$，随机多项式：

$$\Lambda = \Lambda_0 + \Lambda_1 X + \Lambda_2 X^2 + \Lambda_3 X^3 = 28 - 5 X - 30 X^2 + 17 X^3$$

选定 $\beta=4,\ell=2,\beta^\ell=16$ ，表示对 4 个 MSB 进行分解。分解之前先对所有参数 rounding。先写成二进制表示：(~~补码。成计组复习了(悲)~~)

$\Lambda\_0 = 28 \longmapsto (0, 1, 1, 1 {\color{red} |} 0, 0)$ after rounding: $\Lambda'\_0 \longmapsto (0, 1, 1, 1);$

$\Lambda\_1 = -5 \longmapsto (1, 1, 1, 0 {\color{red} |} 1, 1)$ after rounding: $\Lambda'\_1 \longmapsto (1, 1, 1, 1);$