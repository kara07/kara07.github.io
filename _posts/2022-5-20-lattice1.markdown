---
layout:     post
usemathjax: true
title:      "LATTICE BASIC"
subtitle:   "Tendency of the (future) days"
date:       2022-05-20 00:00:00
author:     "kara"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - crypto
    - Computational Complexity Theory
---

前面所讲的计算复杂性理论在格的研究中有着非常重要的作用，格密码之所以被公认能够地抗量子计算攻击很大程度上取决于数学家以及理论计算机科学家对格上的计算问题的研究。第一篇文章以简介为主题，先从直观的角度讲一讲这一领域的历史进程。这一部分不涉及到数学，首先希望大家能够对格这一代数结构有一个直观的认识。

# 为什么研究格？

格在密码学中的作用与有限域上的椭圆曲线类似，都是一种代数，而在这种代数上有很多密码学家所期望的数学性质，比如后面将会讲到的格密码作为欧几理德空间(向量空间)的离散子集，主要使用的是有限域上的加模、乘模运算，无需使用经典代数里的指数、对数运算等，运算效率会高很多；一些格上的计算问题存在从最坏情况到平均情况的归约，我们将这些计算问题归约到自己的密码方案后，其安全性基于计算问题的最坏情况复杂度，换言之，基于格问题的密码原语总是存在安全性归约且有充分的安全性证明，这是RSA等基于平均情况复杂度的方案所很难做到的，[我们无法将整数分解问题归约至RSA](https://crypto.stackexchange.com/questions/89883/is-it-proven-that-breaking-rsa-is-equivalent-to-factoring-as-of-2021)。这一点也是很多学者认为格密码可以抵抗量子计算攻击的一个依据，并且这是在其他代数结构里未被发现的一个性质。格还有很多出色的性质，后面有机会会详细讲到。

关于格在密码学中的应用。人们总是过度关注格在抗量子计算攻击中的应用，但实际上利用格可以实现几乎所有的密码原语，可以在"[minicrypt]((https://www2.karlin.mff.cuni.cz/~krajicek/ri5svetu.pdf))"高度，也可以在"[cryptomania]((https://www2.karlin.mff.cuni.cz/~krajicek/ri5svetu.pdf))"高度(平均复杂度的五个世界)。其在许多领域也有关键应用，比如

1. 密码分析：格基归约破解RSA
2. 编码理论：无线电传输
3. 最优化：固定维度下的整数规划
4. 密码学：全同态加密

后面有机会可以讲到这些应用。格密码在公钥密码里面的密钥尺寸问题随着近些年新的代数结构不断提出，现在已经可以跟RSA扳扳手腕了，加上其本身具有的计算效率优势，我相信基于格的公钥密码在量子计算机实用化之前就能成为新的工业标准。

# 格是什么？

这里有一个例子，在某个区域有规律的图形

![avatar](/img/lattice/lattice1.jpg)

这就是格，虽然实际上它是土豆，不过表示的是一个东西，他们都按照一定规律排布。所以我们以后可以用土豆来表示格。密码学里面所使用的格是高维空间里的点集，且点的排布呈现周期性规律。在这个阶段我不会详解格的数学定义，这里只是给大家一个概念。一个二维的格的例子。

我选择了\\(v_1\\)和\\(v_2\\)，这两个向量，然后选取它们的全部整数组合。举例来说，我们有 \\(2v_2\\) ， \\(v_1+v_2\\)  ，\\(2v_1\\) 。我们也可以选择负数，比如\\(-v_1\\) ，这个点没在图里面。但实际上，点集会遍布整个空间，遍布所有方向。很显然，0点永远包含在格点中。我想大家可以从图中对格有个直观感觉了，这些都是这两个向量的整数组合，所形成的点集有点像网格，我们把这称为格。

我们一般会把这两个点称为格的基。多少维的格就有多少个的基。这个定义很像向量的线性空间，只不过我们这里只选取整数组合。我们通过这种方式得到了有规律的点集的形式化描述。

我们来讲一讲为什么格在密码学中有如此重要的地位。我们形象地举个例子。我们选择这两个向量， \\(v_1\\)和\\(v_2\\)，然后想一想这两个向量生成的格是什么。一眼看上去，你可能会觉得 \\(v_1+v_2\\) 是一个特别长的向量，和原点离得很远，所生成格的形状可能很奇怪。

但实际上如果你仔细思考一下的话，就会发现这才是所生成的格。对比开始时想象的结果，你可能会觉得很惊奇，所生成的格点可以离原点这么近。但实际上向量是可以相减的，你可以计算 \\(3v_2-4v_1\\) ，你就会得到这个和原点距离非常近的点，这就是格之所以如此有用的一个原因，因为即使基向量很长，格点和原点距离也可能非常近。

我想给大家讲解的是，格的基向量并不是唯一的，这是格的另一个性质。 \\(v_1^{\prime}\\)和\\(v_2^{\prime}\\)这两个向量也是同样一个格的基。这在密码学中有很重要的作用，大家在后面也能看到，我们可以试着用格基隐藏格原本的结构特性。我可以不给你 \\(v_1^{\prime}\\)和\\(v_2^{\prime}\\) ，只给你 \\(v_1\\)和\\(v_2\\) 。

来看看格的历史。这里是研究格的数学家先驱们。照片上他们看起来好像很不开心，我也不知道为什么。最近数学家的照片看起来会开心些，可能是因为格理论有了些进展。

历史上，在19世纪早期，人们主要是从数论的角度开始研究格。人们关注格的数论方面性质，而不是格的应用。1801年高斯开始研究格，然后是Hermit、Minkowski。Minkowski在格的研究方面做出了突出的贡献，现在大家都可以学习到Minkowski的研究成果了，也就是Minkowski定理。他们当时关注的是不同的问题，并没有关注密码学应用，但这个定理直到现在都有重要的应用价值，所以Gauss、Hermite和Minkowski，他们是格领域主要的数学家们，我们今天会看到他们的一些成果。

近期，在20世纪，我们会看到新一代的数学家们给出了新的研究成果。学者们提出了一个非常重要的研究成果，主要被运用在密码分析领域，这个成果叫LLL算法，或者叫3L算法，是Lenstral、Lenstral和Louvasz提出的。

这是他们三个的照片。他们三个看起来开心点了。不知道大家看不看得出来，照片里好像挺冷的，但是他们还是挺开心。这是1982年的照片，他们在一起研究这个算法时拍摄的。

这个算法的结果非常令人惊异。这个算法最开始用于寻找格中的近似最短向量，当然我们现在也会这么用，后面如果我还讲的话会讲到近似最短向量是什么意思。本质上说，这个算法可以用来寻找离原点比较近的一个格向量。

但实际上，这个算法最初被用于在实数域分解多项式，以及在固定维度下解决整数规划问题，这是Lenstral在后面的论文中提出的。这个算法在整数分解问题上具有重要应用价值。什么叫在实数域分解多项式呢？就是把一个多项式分解为低阶的多项式，并且是在实数上进行分解。

另一个应用领域是下面这个，我们现在也可以在类似Maple的数学工具中做这样的运算。假设我们计算得到了一个数，经过了很长时间的计算，最后得到了：6.73205...你估计会觉得这可能是个很特殊的数，可能是某个数的平方根，或者是某个数的立方根。大家觉得呢？这个数是不是看起来挺熟悉的？实际上这是个非常简单的例子，大家可能能看出来结果是什么。这个数等于 \\(\root{3}+5\\) 。这是个非常简单的例子，我们可以使用LLL算法来实现这样的功能。实际上我们可以在任意数上做这样的操作。你只需要输入一个数，算法就会告诉你它可能是哪些数运算得来的。这就是LLL算法的另一个重要应用。

继续往下，这是一些历史知识。这是1982年的事情。绝大多数系统都是基于RSA密码学系统的。这是Rivest、Shamir、Adleman在1977年提出的，他们发明的这个密码学系统我们一直还在使用。基于格的密码学系统从某方面讲，将成为密码学系统的另一种选择。因为格密码学有成为另一种选择的潜力，也是一个很好的备选方案。有很多理由支持我们转入基于格的密码学系统。

密码学和格第一次牵手是在LLL算法提出后没多久。人们想，我们现在有密码学算法了，也有LLL算法了，我们可以做一些很棒的事情，没准我们可以用LLL算法破解密码学方案，或者用于对密码学方案进行分析。实际上，即使现在，密码分析学也是LLL算法的一个重要应用领域。它可以作为一个密码分析学算法，用于破解密码学方案，给出方案应用方法的建议。举例来说，LLL算法可以破解基于背包问题的密码学系统。LLL算法可以破解RSA的变种方案。如果你在特定的配置环境下使用RSA算法，则可证明应用LLL算法可以破解RSA。这是一个非常棒的研究成果。这个领域也有很多分支。但是我今天并不会过多讲解这方面的内容。

我们的重点是要讲解如何构造密码学方案，如何应用格来构造密码学方案。这就是今天的主题，如何使用代数结构格，使用格上的计算问题构造密码学方案。如何构造公钥密码学方案，或者构造其他密码学函数，构造很多其它的密码学方案。这是1996年开创的领域，Ajtai首先进行了尝试。为什么我们关心这个领域呢？事实证明，格密码学有很多整数分解或者离散对数等传统假设不具有的特性。

格的安全性更高。我们现在在考虑数学证明，但是首先我们要注意，我们不能证明所有的方案都是安全的，无法证明基于一系列NP问题构造的密码学方案就一定是安全的。但我们可以证明，这些密码学方案的安全性与与格的特定困难问题等价，而且我们相信这些困难问题确实很难。在后面几页幻灯片中我会讲到这一点。

另一个很棒的特性是，格密码学方案可以抵御量子计算机的攻击。现在可能绝大多数人已经知道，量子计算机可以解决整数分解问题，可以解决离散对数问题，也就可以破解传统的所有密码学方案。量子计算机还可以做很多其他的事情。我想说的是，在其他可以抵御量子计算攻击的候选算法中，格密码学可以排在很高的地位，可能是最高的地位。这也是为什么我们要研究它的一个原因。我们现在还没有实用的量子计算机，这仍然是未来才可能出现的东西，科学家们仍然在尝试构造量子计算机。但如果你想构造一个10年内安全的密码学方案，可能就需要开始担心量子计算机了。我们知道，我们可能在这段时间内得到量子计算机，所以我们需要担心这一点。对于我们现在发送的一些数据，我们至少需要在10年内保证加密的安全性，所以我们现在就应该开始担心量子计算机的诞生了。这很严峻，因为我们没有太多的备选密码学方案，但是我们又不得不依靠密码学来实现一些功能。而格密码学是抵御量子计算机攻击的备选密码学方案。我在后面会提到格密码学的另一个优点。在某些情况下，格密码学的运算速度比较快，并且格密码学可以提供更多的功能。

我们大致讲了讲为什么我们要研究格密码学。现在，我们尝试高维度地看看，如何使用格构造密码学方案。为什么格可以用来构造密码学方案？简单来说。假定我们有这样一个格、我们一般使用高维格，不是这种2维格，我们一般使用更高维度的格，比如500维的格。基本思想是，如果我们随机选择一个格点，然后我进行扰乱，把点移动到这里。我选择了一个格点，把它往下移动了一些。现在，从计算角度很难得知这个点是否从这个格点移动来的，很难得知这个点是从哪个格点移动来的。在2维格中，这个问题看起来比较简单，但如果是500维格的话，我们可以沿着很多方向移动，向上、向下…在高维中我们可以有很多移动方向，这就是格问题复杂度的来源。

实话实说，大家在一些相关的论文中可能看不到这些困难问题，因为现在这些困难问题都被进一步封装，使得其可以更好地应用于密码学方案中，比如SIS问题、LWE问题。实际构造时可能用不到这个问题，不过这是格密码学构造的基本思想。也就是说所有的计算问题都可以归约到这个问题。

我们来更深入的讲一讲，格密码学有什么优点？我前面说到，第一个优点是可证明安全。现在，我们在构造密码学方案时一般会伴随一个特定的安全性证明。这个安全性证明定义了参数，并且指出，如果你能破解密码学方案，比如如果你能破解公钥加密的私钥，或者可以对单向函数求逆，即使破解的概率非常低，几乎可以忽略，也会发生很奇怪的事情。如果能破解密码学方案，你也就可以解决格中的困难问题了。安全性证明的工作就是如此，实际上告诉我们在构造密码学方案时，没有漏掉一些构造细节，没有留下安全缺口或者脆弱的漏洞。我们可以证明如果方案被破解了，就会发生这种奇怪的事情，这是一个非常好的性质。在传统密码学中，我们不一定能得到安全性证明。有些时候我们能证明方案满足特定的安全性，但是即使RSA系统，我们不知道是不是破解RSA一定意味着可以解决整数分解问题。有的密码学方案具备这样的特性，比如说同样基于整数分解问题的rabin密码，它和整数分解问题是等价的，就是说rabin系统的安全性和整数分解问题互相归约。并不是所有的密码学方案都有这个特性。但在格密码学中，大概零几年往后所有方案构造都可以得到安全性证明。这就是第一个优点。

格密码学与传统密码学的第二个对比点是，格密码学所得到的安全性更高。这个优点非常好，叫做最坏情况安全性。这是格中所独有的优点，在其他代数结构中似乎都没有这个优点。这是个非常棒的优点，我会在下面两页幻灯片中详细讲解。这个优点的意思是，如果你可以破解密码学方案，那么你就可以解决最坏情况下的困难问题，你就可以解决所有格上的困难问题。在下一页幻灯片中我还会提到，传统密码学是没有这个特点的，传统密码学的安全性一般基于平均情况困难问题的复杂度。这是一个非常棒的优点，这也是为什么Ajtai在20世纪90年代中期的工作得到了这么广泛的关注。这是一个新的思想，是一个新的特性。这个特性很奇特。与整数分解相比，这是一个相对较新的困难问题。如果把数学家的工作考虑进来的话，这个困难问题已经有200年的历史了，但在计算机科学领域，这个困难问题只有40年的历史，是个新提出的困难问题。

另一个优点是格计算问题不能被量子算法解决。因为这确实是一个很困难的问题，我们可以基于它构造密码学方案。到现在为止，量子算法还不能解决这些困难问题。当然我不知道是不是一定不能解决，寻找解决格困难问题的量子算法是个很重要的公开问题。学者们已经寻找了25年，到现在为止还是没有能解决格困难问题。所以可能格问题确实很困难，可能即使在量子算法下，格问题仍然很困难。

我还要提到的一个优点是，如果使用基于整数分解的密码学系统，此类方案经常要进行乘法、指数运算，这类运算的计算开销对于笔记本来说并不大。但对于小型嵌入式设备，比如智能卡，乘法和指数运算这类运算的计算开销就比较大了。对于格密码学来说，很棒的一个特性是，格密码学的计算开销很小，只是进行一系列加法运算。特别是最近几年，学者们提出了很多非常高效的格密码学方案。所以即使从效率的角度考虑，格密码学也具有巨大的优势。

最后一个优点是我们可以用格实现其他令人惊讶的密码学功能，比如全同态加密。这是一个开创性的工作成果，我们可以用格实现传统密码学无法实现的全同态加密。此方案的设想是在20世纪90年代中期提出的，没人能想到这竟然可以实现，没人能想到我们可以利用格实现实现整数分解无法实现的一些密码学特性。以前学者们一直认为整数分解这类数论假设是最强的一类假设，但实际上格也可以实现很多功能。

我们来深入讲解一下这些特点。第一点是可证明安全性。正如我前面提到的，我们不能证明某些方案是绝对安全的，没人可以证明如果P等于NP，那么所有方案都可以被破解。当然信息论安全除外。那可证明安全又是什么呢？可证明安全将密码学构造与一些我们认为可信的结论联系在了一起。可证明安全是一种归约算法，它将一个计算问题的困难性归约到密码学方案的安全性上。这个困难问题不是一拍脑袋想出来的，而是一个经过学者们的广泛研究、已确定困难的问题。我们把这类困难问题归约到一系列密码学函数上，这就是安全证明。我们希望利用安全性证明来讨论方案的安全性。我后面可能就会提到，在很多情况下，安全性证明很有用，它告诉我们应该如何使用一个密码学方案。同时，它也告诉我们如果可以破解密码学方案，如果存在一个攻击者以一定概率破解密码学方案，就会发生一些奇特的事情，也就是我们的困难问题不再困难了，整个假设都被破解了。不光是你构造的算法不再安全，所有依赖于这一困难问题的密码学构造都不安全了。甚至能用来证明P=NP。所以这是个非常好的结论，我们总希望能得到这样的结论。但我们并不是经常能得到这样的结论，但格密码学可以得到更强的安全性结论。

这是个非常好的特性，安全性证明会告诉我们所构造的方案没什么问题。如果你有一些疯狂的idea，想要去构造密码学方案，首先你需要得到安全性证明，能把所构造的方案与一个困难问题联系到一起，你就会知道你的想法是正确的。可能你忘记了加什么东西，因为不加或者不做某个运算，方案可能不安全，但是如果有安全性证明的话，这种事情就不会发生。同时，安全性证明可以告诉我们如何选择方案的参数。这也和下面的一个特性相关。你有了一个密码学方案，但里面涉及一些参数，比如某些特定的数要大于其他数。大多数情况下，你可能不知道如何选取这些参数。但如果有安全性证明的话，它就会告诉你，如果安全性证明能通过，则 \\(m>n^2\\)比如说 ，所以你在使用方案的时候，会把m选为大于n^2的数，这样安全性证明才能过得去。

密码学历史中也发生过这样的事情。我们证明了一个方案是安全的，安全性证明告诉我们，一部分参数要大于n^2。我们会说，用的时候就让这些参数大于n^2吧。那个时候我们还不知道为什么。但是5年以后，学者们提出了另一个算法。这个算法指出，如果这些参数小于 n^2，我们可以在亚指数时间内破解密码学方案。大家可以看到安全性证明的作用了，它会告诉我们怎么做才是正确的，或者是否走在了正确的道路上。

我来举个例子，来看看安全性证明大概是个什么样子。这也会涉及到下面一个优点，也就是最坏情况、平均情况困难性这个优点上。这是个很简单的例子，是一个基于模平方的单向函数，这只是给大家解释下基本思想。假设你希望构造这样一个单向函数，这个单向函数是将输入值求平方，输入值为 x ，输出为 x^2。令N为两个大素数的乘积，我不知道如何选择参数N，后面几分钟我就会提到怎么选择参数N了。现在就选择某个N，这个N是两个大素数的乘积。现在考虑这个函数，求x^2模N。

大家可以试着证明，如果想求这个函数的逆函数，也就是给定x^2，其中x是随机选取的，找到任意一个x'，使得x'^2=x^2。我们可以很容易证明，如果可以找到原像，就可以分解整数N。这就是安全性证明的一个例子，它证明了如果你可以以不可忽略的概率求逆函数，那么你就有更高的概率，也是不可忽略的，或者某个不能用代数式表示的概率下，你可以分解N。我们实际上就是在证明这个单向函数的安全性。现在有了安全性证明，它证明了这个单向函数的安全性与整数分解相关，这是个挺不错的单向函数。但是这引入了另一个问题，这个函数，这个安全性证明叫做平均情况困难证明，基于平均情况困难性。基于平均情况困难性的原因是，我们没告诉你怎么选择 N 。如果问如何选择 N ，只能告诉你 N 等于两个大素数的乘积，我们还需要知道其他一些限制条件吗？大素数本身是不是要满足一些性质？是不是有所谓好的素数和不好的素数？这好像不那么显然，可能没有什么直观的结论。这实际上是一个很重要的问题，一个大问题，这引发了下面的问题，也就是我们如何选择 N 。

我们在RSA下看看这个问题。你想用代码实现一个RSA，如何选择模的参数 N ？如果你之前了解过，你会知道 N 不能是个偶数，偶数 N 不是个好选择。所以你估计会选择两个大素数，然后把它们乘起来。教科书上一般就讲到这里，但有可能某些素数比其他素数好？大家觉得呢？你觉得什么素数算是个好素数？这个问题有答案吗？

这是个好问题，我们其实不知道这个问题的答案是什么。但我可以告诉你历史上发生了什么事情。1978年，学者们开始研究整数分解算法了。那时候RSA出现了，人们意识到整数分解是一个重要问题，试着寻找整数分解算法。1978年，学者们发现存在一个高效的算法分解整数，前提是 p-1 或者 q-1 的最大质因子要比较小。所以人们说，如果你让RSA抵御这类攻击的话，你需要选择 p 和 q ，使得 p-1 和 q-1 的最大质因子比较大，不能太小。于是在1978年，你在代码里面增加了一个检查机制，检查 p 和 q 是不是满足条件。

接下来，1981年又出来另一篇论文，对于另一个特定情况又有了另一个算法， p+1 和 q+1 需要有比较大的质因子。于是你又增加了一行代码，保证 p 和 q 也满足这样的条件。

又过了1年，又出来了一篇论文，如果 p-1 和 q-1 的最大质因子是 p‘ 和 q’ ，那么 p‘-1 和 q‘-1 也要有大的质因子。好，那我们得再检查下这个是否成立。

大家估计可以猜到接下来发生什么了吧？1984年，学者们发现如果 p+1 和 q
+1 的最大质因子是 p' 和 q' ，则 p'-1 和 q'-1 也需要有比较大的质因子。大家估计没听说过有这么个历程，原因是我们现在有了更高效的大整数分解算法。我们发现了数筛法，所以现在这4个要求已经没这么重要了，我们已经有了更高效的整数分解算法，对于所有 N=pq 的形式，上面这4个算法的效率和数筛法效率差不多。可能对于不同的 p' 和 q' ，整数分解的效率还是会有所不同，但是我想这不会意味着故事的结束。在接下来的时间里，学者们可能会提出更高效的算法。我们要根据所提出的算法选择更为特殊的素数，这确实是不断在发展的一个问题。

为什么会有这样一个问题？问题出在安全性证明上面。安全性证明称如果能破解RSA，并不意味着能分解所有的整数，只意味着能分解某个特定的整数，只能分解一个特定的N ，不是所有的 N 。这就是所谓的平均情况困难性。所以如果你相信破解RSA或者破解其他基于整数分解问题的方案是困难的，你相信的是在平均情况下，整数分解是困难的。你需要相信的并不是所有整数分解都是困难的，只有一部分整数分解是困难的。我们这里假设的是，可能有1%的数是容易分解的，这1%的RSA方案是可以破解的，但是在最坏情况下，整数分解还是困难的。所以我们可以选择一定的分布，把目前我们认为困难的 N 作为一个分布，密码学方案只从这里面选。当然，也有可能我们在未来，对这个特定分布中的某些特定的数也可以很快进行整数分解，那我们就需要不断判断哪些数已经不再安全，并且不断的更新这个分布。这确实是一直困扰我们的一个问题。但格里面没有这样的问题，这是一个重要的核心优点，格困难问题是最坏情况困难问题。

我们从密码学函数的角度再理解一下。如果你基于平均情况困难性进行安全性证明，得到的是类似于这样的映射关系。你选择了这个参数 N ，右边你就得到了一个基于 N 的密码学函数。这有点像双射，有点像一对一映射。对于每个 N ，你都证明了存在这个 N 所对应的密码学函数。如果密码学函数被破解了，你就能分解这个 N ，确实有点像一对一双射。如果你突然发现1%的密码学方案被破解了，你得到的只是 N 中1%的数可以被分解，不是能分解所有的数，只意味着能分解1%的数。

而在格中我们可以得到更好的结论，这就是所谓的最坏情况困难性。什么是最坏情况困难性？他的安全性归约，或者说安全证明更像是一个完全映射。在左边选择一个任意的格，把它映射到右边，它会映射到右边所有的密码学函数。这个映射关系非常令人惊讶，很神奇。这就是最坏情况困难的主要思想。从某种程度上，你将任意一个格困难问题都映射到了密码学函数的整个空间里面，这也意味着，如果1%的密码学函数被破解了，则任意一个格计算问题实例都可以被解决。

从很多方面看，这都是一个很好的性质。首先，这使得安全性强度更高了，不光是安全性强度更高了，而且它也告诉我们，不需要担心如何选择参数 N 了，只要按照某个分布，能让方案正常运行的分布，选参数就可以了。安全证明会告诉你如何正确选取参数，你只要这么选就好了，不需要担心哪个是好的 N ，哪个是不好的 N。

今天对于格，这只是一个简单的介绍。正如我前面所说的，Ajtai在1996年开创性地提出了格密码学。他也意识到我们可以使用格做很多很棒的事情。他告诉我们如何实现单向函数，如何实现公钥密码学，但是他们只提出了一个概念指出这些是可以用格来实现的。他也指出如何得到最坏情况安全性。但从性能方面考虑的话，他们构造的方案效率非常低。如果使用他们所提出的系统，密钥可能是GB级的，效率很低，很麻烦。我认为他的构造更多地是从理论的角度考虑的。

但是，最近几年，格密码学有了翻天覆地的变化。现在我们已经得到了非常高效的格密码学方案，其效率甚至可以与RSA比拟。开始时方案看起来根本没法用，也没什么可扩展的能力，只能做公钥密码学系统，而且绝大多数公钥密码学系统的构造都很繁琐，仅获得选择明文安全性已经非常困难了，而且几乎没有任何可扩展性。随后Louis和Warick试着定义格密码学系统，延伸这个思想。最近几年，学者们集中研究格密码学的两个核心问题，用这两个问题可以构造非常高效的密码学方案，非常高效的单向函数。而且这两个问题把格的一些内容抽象化了。当你设计格密码学系统的时候，不需要去考虑最坏情况困难性的安全性证明，你只需要基于SIS、LWE这两个中间问题构造方案就可以了，有人已经把最困难的问题解决了，他们完成了最坏情况证明。你只需要选一个问题，用这个问题构造密码学系统就好了。当然这方面还有很多工作要做，但至少一部分工作已经完成了。这就是近几年格密码学的研究主线。

同时，格密码学还有另一个研究主线。这个主线所构造的密码学方案非常非常高效。他们是基于特定格代数结构而构造的。这类被称为Ring-LWE以及Ring-SIS。2002年Micciancio开创了这一领域。他意识到如果不考虑一般格，只考虑循环格这种满足特定性质的格代数结构，就可以大幅度提高方案的效率，构造安全高效的密码学方案，而且所构造的密码学方案确实非常高效。密钥的长度是KB级的，而计算效率甚至可以和哈希函数的计算效率接近了。现在所提出的利用格所构建的很多密码学原语，很多密码系统，都采用了基于特定代数格的结构。

今天的时间差不多也到了，这次演讲没有涉及到很多的数学和具体的方案，只是想让大家有一个初步的，直观的认识，知道有这样一类计算问题，基于他所构建的方案安全且高效，并且很有可能成为未来的主流。下次演讲可以和大家一起探讨格密码的数学性质和细节构造，以及如何证明其从最坏情况到平均情况的归约，使他具有最坏情况困难性，以及如何利用格构造密码学原语和密码学系统。